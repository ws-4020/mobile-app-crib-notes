---
title: HTTP APIの呼び出し
---

このアプリケーションでは、バックエンドサーバが提供するREST APIを用いてデータの参照・更新・削除などを行います。
その際には、[Orval](https://orval.dev/)というツールを用いてOpenAPI Specificationから自動生成したコードを用いてリクエストを送信します。
ここではその使い方について説明します。

## Backend APIの呼び出し

### クライアント側コードの自動生成

クライアント側のコードを自動生成するためには、まずバックエンドAPIの仕様に沿ったOpenAPI定義ファイルを用意する必要があります。
OpenAPI定義ファイルを作成したら、それに合わせてOrval実行時のInputとOutputに関する設定ファイルを作成します。
このアプリでは、以下のように設定します。

| Key                          | 概要 | 今回設定する値 |
|:-----------------------------|:-----|:--------------|
| input.target                 | OpenAPI定義ファイルのPathを指定 | ../api-document/openapi.yaml |
| output.target                | 自動生成するコードのうち、メインとなるファイルを出力するPathを指定 | src/generated/backend/api.ts |
| output.schemas               | 自動生成するコードのうち、Modelファイルを出力するPathを指定 | src/generated/backend/model |
| output.client                | 自動生成するコードの中でどのHTTP Clientライブラリを利用するかを指定 | react-query |
| output.mode                  | 自動生成するコードをどの粒度でファイル分割するかを指定 | tags-split |
| output.prettier              | 自動生成されたコードにprettierを適用するかを指定 | true |
| output.clean                 | 自動生成の際に古い自動生成コードを削除するかを指定 | true |
| output.query.options.retry   | 自動生成されたコードで利用するReactQueryのデフォルトオプション (今回はRetryについてのみ設定） | false |
| output.override.mutator.path | デフォルトのAxiosInstanceをカスタマイズしたい場合に、CustomInstanceが定義されているファイルのPath | src/framework/backend/customInstance.ts |
| output.override.mutator.name | 上記ファイル内でexportしているCustomInstanceのfunction名 | backendCustomInstance |

また、無限スクロールの実現のため、バックエンドAPIの中にuseQueryの代わりにuseInfiniteQueryを利用したいAPIがある場合は、
さらに以下の設定を追加します。

| Key                          | 概要 | 今回設定する値 |
|:-----------------------------|:-----|:--------------|
| output.override.operations.<対象APIのOperationId>.query.useInfinite | useQueryの代わりにuseInfiniteQueryを使うかどうか | true |
| output.override.operations.<対象APIのOperationId>.query.useInfiniteQueryParam | API呼び出し時にuseInfiniteQueryのnextPageParamの値を設定するクエリパラメータ名 | cursor (対象APIのクエリパラメータ名） |

設定が終わったら、以下のコマンドでOrvalを実行し、クライアント側コードを自動生成します。

```bash
// このアプリでは npm run orval でも実行できるようにpackage.jsonに設定済み
npx orval --config ./orval.config.ts
```

後からAPI仕様に変更があった場合は、OpenAPI Specificationのファイルを更新した上で同じコマンドを実行します。

### 自動生成されたコードの利用

Orvalを実行すると、OpenAPI Specification内に記載した各APIに対して、OperationIdに対応する名前のCustom Hookが自動生成されます。
例えばOperationIdがget-csrf-tokenの場合、useGetCsrfTokenという名前のCustom Hookが自動生成されます。

このアプリでは、自動生成されたCustom Hookを直接importして各所で用いるのではなく、
必要に応じてカスタマイズした上で提供できるサービス層を設けるものとします。
サービス層では、自動生成されたCustom Hookをもとに、API呼び出しの成功時の処理やエラー時の処理を追加したCustom Hookを提供します。
カスタマイズする必要のないAPI呼び出しについては自動生成されたCustom Hookをimportしてそのままexportします。

自動生成されたCustom Hookは、APIのHTTPメソッドやOrval設定によって3種類に分けられます。
それぞれがReact QueryのuseQuery, useInfiniteQuery, useMutationの3種類に対応しています。
それぞれの使い方は以下のとおりです。

#### データ取得 (useQuery)

HTTPメソッドがGETのAPIに対しては、基本的にはuseQueryをベースとしたCustom Hookが自動生成されます。
第一引数にはクエリパラメータ、第二引数にはオプションを設定できます。
指定できるオプションや戻り値は、React Queryの[useQuery](https://react-query.tanstack.com/reference/useQuery)とほぼ同様です。
利用時のコード例は以下のようになります。

```typescript
import React from 'react';
import {View, Text, Button} from 'react-native';
import {useGetAccountsMe} from 'service/backend';

const SampleScreen: React.FC = () => {
  // 以下のようなResponseBodyが返ってくるAPIの場合の例
  // {"nickname": "NickName"}
  const {isLoading, isError, data: axiosResponse, refetch} = useGetAccountsMe();

  if (isLoading) {
    return (
      <View>
        <ActivityIndicator />
      </View>
    );
  }

  if (isError) {
    return (
      <View>
        <Text>アカウント情報の取得に失敗しました。</Text>
        <Button title="再取得" onPress={() => refetch()} />
      </View>
    );
  }

  return (
    <View>
      <Text>{axiosResponse.data.nickname}</Text>
    </View>
  );
}
```

#### 無限スクロール用データ取得 (useInfiniteQuery)

OrvalのConfigファイル内でuseInfinite:trueに設定したAPIに対しては、useInfiniteQueryをベースとしたCustom Hookが自動生成されます。
第一引数にはクエリパラメータ、第二引数にはオプションを設定できます。
指定できるオプションや戻り値は、React Queryの[useInfiniteQuery](https://react-query.tanstack.com/reference/useInfiniteQuery)とほぼ同様です。
利用時のコード例は以下のようになります。

```typescript
import React from 'react';
import {View, Text, Button} from 'react-native';
import {useListTodoByCursorInfinite} from 'service/backend';

const SampleScreen: React.FC = () => {
  // 以下のようなResponseBodyが返ってくるAPIの場合の例
  // {"hasNext": true, "nextCursor": 20, "content": {"title": "Todo Title"}}
  const {isLoading, isSuccess, isError, data, refetch} =
    useListTodoByCursorInfinite(undefined, {
      query: {
        getNextPageParam: lastPage => {
          return lastPage.nextCursor;
        },
      },
    });

  const todos = useMemo(() => {
    if (isSuccess && data) {
      // data.pagesには、各クエリに対するレスポンスが配列で格納されている
      return data.pages.map(axiosResponse => axiosResponse.data.content).flat();
    } else {
      return [];
    }
  }, [isSuccess, data]);

  if (isLoading) {
    return (
      <View>
        <ActivityIndicator />
      </View>
    );
  }

  if (isError) {
    return (
      <View>
        <Text>TODO一覧の取得に失敗しました。</Text>
        <Button title="再取得" onPress={() => refetch()} />
      </View>
    );
  }

  return (
    <View>
      {todos.map(todo => {
        return <Text>{todo.title}</Text>;
      })}
    </View>
  );
}
```

#### データ更新・削除 (useMutation)

HTTPメソッドがPOST, PUT, DELETEなどのAPIに対しては、useMutationをベースとしたCustom Hookが自動生成されます。
基本的な使い方や指定できるオプションは、React Queryの[useMutation](https://react-query.tanstack.com/reference/useMutation)とほぼ同様です。

```typescript
import React, {useCallback, useState} from 'react';
import {View} from 'react-native';
import {Input, Button} from 'react-native-elements';
import {usePostTodo} from 'service/backend';

const SampleScreen: React.FC = () => {
  const [title, setTitle] = useState<string>();
  const postTodo = usePostTodo();

  const onSubmit = useCallback(async () => {
    if (title) {
      try {
        const response = await postTodo.mutateAsync({data: {title}});
        // 成功時の処理
      } catch (e) {
        // 失敗時の処理
      }
    }
  }, [title, postTodo]);

  return (
    <View>
      <Input label="Title" onChangeText={value => setTitle(value)}>
        {title}
      </Input>
      <View>
        <Button title="Submit" onPress={onSubmit}} loading={postTodo.isLoading} />
      </View>
    </View>
  );
};
```

データを更新しても、それ以前に取得したクエリのキャッシュデータは残ったままです。
クエリのキャッシュデータは、マウントされている全ての画面で利用されなくなった後、さらにcacheTime（デフォルト5分）が経過するまではそのまま利用されます。
このアプリではstaleTimeを0に設定しているため、こうしたデータはReact Queryによる次のrefetchのタイミングで更新されます。
しかし古いクエリキャッシュはなるべくすぐに無効化・更新することが望ましいです。

React Queryでは、クエリキャッシュを無効化する方法として、InvalidateとResetが用意されています。
Invalidateの場合は、古いデータを画面表示したまま、最新データを取得します。
Resetの場合は、古いデータを削除して画面表示されないようにした上で、最新データを取得します。
このアプリでは、更新系のAPI呼び出し成功時にResetを用いて関連する古いクエリキャッシュを無効化するよう、サービス層のCustom HookでonSuccessの処理を追加します。

### エラーハンドリング

このアプリでは、HTTP API通信に関するグローバルエラーハンドリングと個別のエラーハンドリングを以下のように実装します。

#### グローバルエラーハンドリング

グローバルエラーハンドリングは、QueryCache/MutationCacheのオプション内で指定するonErrorを用いて実装します。
QueryCache/MutationCacheのオプション内で指定するonErrorは、他のonErrorの指定によって上書きされず、常に実行されます。

グローバルエラーハンドリングでは、以下のようなエラーに対する処理を行います。

- API呼び出しに対する応答ステータスコードが4xx、5xx番台だった場合の共通処理
  - 例： 429 Too Many Requests応答が返ってきた場合に、アクセスが集中しているためしばらく時間をおいてアクセスしてほしい旨をスナックバーで表示
- 予期せぬエラーだった場合の処理
  - 例： Firebase Clashlyticsへエラーログを記録した上で、予期せぬエラーが発生したことをスナックバーで表示

個別にエラー処理を実施するためグローバルエラーハンドリングが不要な場合は、以下のいずれかで無効化できるようにしています。

- サービス層で、queryOptionsとして```{meta: {disableGlobalErrorHandler: true}}```を指定したCustom Hookを用意して利用する
- useQueryやuseMutationに渡す非同期関数内で、ApplicationErrorを継承したエラーをthrowする

#### 個別のAPI呼び出しに関するエラーハンドリング

個別のAPI呼び出しに関するエラーハンドリングは、以下のいずれかで実装します。

- useQuery, useMutationのオプション内で指定するonError
- useQuery, useMutationのResultとして取得できるisError, errorを見ての処理
- mutateAsyncを呼び出した箇所でのtry/catch処理

上記の中から、画面描画への反映が必要かどうかなどエラー処理の内容を考慮して適切なものを選択します。

## その他の外部サービスの呼び出し

Orvalによって自動生成されるのは、バックエンドAPIへのリクエスト用のCustom Hookのみです。
その他の外部サービスを利用する際には、各外部サービスが提供するSDKを別途利用します。
外部サービスがSDKを提供していない場合は、その外部サービスのOpenAPI Specificationを作成した上でOrvalによる自動生成を別途行います。
