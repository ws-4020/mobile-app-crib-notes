---
title: HTTP APIの呼び出し
---

このアプリケーションでは、バックエンドサーバが提供するREST APIを用いてデータの参照・更新・削除などを行います。
その際には、[Orval](https://orval.dev/)というツールを用いてOpenAPI Specificationから自動生成したコードを用いてリクエストを送信します。
ここではその使い方について説明します。

## Backend APIの呼び出し

### クライアント側コードの自動生成

クライアント側のコードを自動生成するためには、まずバックエンドAPIの仕様に沿ったOpenAPI定義ファイルを用意する必要があります。
OpenAPI定義ファイルを作成したら、それに合わせてOrval実行時のInputとOutputに関する設定ファイルを作成します。
このアプリでは、以下のように設定します。

| Key                          | 概要 | 今回設定する値 |
|:-----------------------------|:-----|:--------------|
| input.target                 | OpenAPI定義ファイルのPathを指定 | ../api-document/openapi.yaml |
| output.target                | 自動生成するコードのうち、メインとなるファイルを出力するPathを指定 | src/generated/backend/api.ts |
| output.schemas               | 自動生成するコードのうち、Modelファイルを出力するPathを指定 | src/generated/backend/model |
| output.client                | 自動生成するコードの中でどのHTTP Clientライブラリを利用するかを指定 | react-query |
| output.mode                  | 自動生成するコードをどの粒度でファイル分割するかを指定 | split |
| output.prettier              | 自動生成されたコードにprettierを適用するかを指定 | true |
| output.query.options.retry   | 自動生成されたコードで利用するReactQueryのデフォルトオプション (今回はRetryについてのみ設定) | false |
| output.override.mutator.path | デフォルトのAxiosInstanceをカスタマイズしたい場合に、CustomInstanceが定義されているファイルのPath | src/framework/backend/useCustomInstance.ts |
| output.override.mutator.name | 上記ファイル内でexportしているCustomInstanceのfunction名 | useBackendCustomInstance |

また、無限スクロールの実現のため、バックエンドAPIの中にuseQueryの代わりにuseInfiniteQueryを利用したいAPIがある場合は、
さらに以下の設定を追加します。

| Key                          | 概要 | 今回設定する値 |
|:-----------------------------|:-----|:--------------|
| output.override.operations.<対象APIのOperationId>.query.useInfinite | useQueryの代わりにuseInfiniteQueryを使うかどうか | true |
| output.override.operations.<対象APIのOperationId>.query.useInfiniteQueryParam | API呼び出し時にuseInfiniteQueryのnextPageParamの値を設定するクエリパラメータ名 | cursor (対象APIのクエリパラメータ名) |

設定が終わったら、以下のコマンドでOrvalを実行し、クライアント側コードを自動生成します。

```bash
// このアプリでは npm run orval でも実行できるようにpackage.jsonに設定済み
npx orval --config ./orval.config.ts
```

後からAPI仕様に変更があった場合は、OpenAPI Specificationのファイルを更新した上で同じコマンドを実行します。

:::note
OrvalでCustom Instanceを利用する設定にした場合、Custom Instanceの実装によってはOrval実行時に以下のWarningが表示されます。

```text
Your mutator cannot be loaded so default setup has been applied
```

これはOrvalのdependenciesにないライブラリやファイルなどをCustom Instanceからimportしていると起こるようです。
実際にアプリから自動生成したコードを利用する際には問題なく利用できるため、今回は特に対応しません。
:::

### 自動生成されたコードの利用

Orvalを実行すると、OpenAPI Specification内に記載した各APIに対して、OperationIdに対応する名前のCustom Hookが自動生成されます。
例えばOperationIdがget-csrf-tokenの場合、useGetCsrfTokenという名前のCustom Hookが自動生成されます。
クライアントアプリからバックエンドAPIを利用する場合は、このCustom Hookを用いてバックエンドAPIを呼び出します。

この自動生成されたCustom Hookは、APIのHTTPメソッドやOrval設定によって3種類に分けられます。
それぞれがReact QueryのuseQuery, useInfiniteQuery, useMutationの3種類に対応しています。
それぞれの使い方は以下のとおりです。

#### データ取得 (useQuery)

HTTPメソッドがGETのAPIに対しては、基本的にはuseQueryをベースとしたCustom Hookが自動生成されます。
第一引数にはクエリパラメータ、第二引数にはオプションを設定できます。
指定できるオプションや戻り値は、React Queryの[useQuery](https://react-query.tanstack.com/reference/useQuery)とほぼ同様です。
利用時のコード例は以下のようになります。

```typescript
import React from 'react';
import {View, Text, Button} from 'react-native';
import {useGetAccountsMe} from 'generated/backend/api';

const SampleScreen: React.FC = () => {
  // 以下のようなResponseBodyが返ってくるAPIの場合の例
  // {"nickname": "NickName"}
  const {isLoading, isError, data: account, refetch} = useGetAccountsMe();

  if (isLoading) {
    return (
      <View>
        <ActivityIndicator />
      </View>
    );
  }

  if (isError) {
    return (
      <View>
        <Text>アカウント情報の取得に失敗しました。</Text>
        <Button title="再取得" onPress={() => refetch()} />
      </View>
    );
  }

  return (
    <View>
      <Text>{account.nickname}</Text>
    </View>
  );
}
```

#### 無限スクロール用データ取得 (useInfiniteQuery)

OrvalのConfigファイル内でuseInfinite:trueに設定したAPIに対しては、useInfiniteQueryをベースとしたCustom Hookが自動生成されます。
第一引数にはクエリパラメータ、第二引数にはオプションを設定できます。
指定できるオプションや戻り値は、React Queryの[useInfiniteQuery](https://react-query.tanstack.com/reference/useInfiniteQuery)とほぼ同様です。
利用時のコード例は以下のようになります。

```typescript
import React from 'react';
import {View, Text, Button} from 'react-native';
import {useListTodoInfinite} from 'generated/sandbox/api';

const SampleScreen: React.FC = () => {
  // 以下のようなResponseBodyが返ってくるAPIの場合の例
  // {"hasNext": true, "nextCursor": 20, "content": {"title": "Todo Title"}}
  const {isLoading, isSuccess, isError, data, refetch} =
    useListTodoByCursorInfinite(undefined, {
      query: {
        getNextPageParam: lastPage => {
          return lastPage.nextCursor;
        },
      },
    });

  const todos = useMemo(() => {
    if (isSuccess && data) {
      // data.pagesには、各クエリに対するレスポンスが配列で格納されている
      return data.pages.map(page => page.content).flat();
    } else {
      return [];
    }
  }, [isSuccess, data]);

  if (isLoading) {
    return (
      <View>
        <ActivityIndicator />
      </View>
    );
  }

  if (isError) {
    return (
      <View>
        <Text>TODO一覧の取得に失敗しました。</Text>
        <Button title="再取得" onPress={() => refetch()} />
      </View>
    );
  }

  return (
    <View>
      {todos.map(todo => {
        return <Text>{todo.title}</Text>;
      })}
    </View>
  );
}
```

:::note
// TODO: Orvalで自動生成したコードは、InfiniteでQueryParameterの中に必須パラメータがある場合に型エラーとなる場合がある
:::

#### データ更新・削除 (useMutation)

HTTPメソッドがPOST, PUT, DELETEなどのAPIに対しては、useMutationをベースとしたCustom Hookが自動生成されます。
基本的な使い方や指定できるオプションは、React Queryの[useMutation](https://react-query.tanstack.com/reference/useMutation)とほぼ同様です。

```typescript
import {usePostTodo} from 'generated/sandbox/api';
import React, {useCallback, useState} from 'react';
import {View} from 'react-native';
import {Input, Button} from 'react-native-elements';

const SampleScreen: React.FC = () => {
  const [title, setTitle] = useState<string>();
  const postTodo = usePostTodo();

  const onSubmit = useCallback(async () => {
    if (title) {
      try {
        const response = await postTodo.mutateAsync({data: {title}});
        // 成功時の処理
      } catch (e) {
        // 失敗時の処理
      }
    }
  }, [title, postTodo]);

  return (
    <View>
      <Input label="Title" onChangeText={value => setTitle(value)}>
        {title}
      </Input>
      <View>
        <Button title="Submit" onPress={onSubmit}} loading={postTodo.isLoading} />
      </View>
    </View>
  );
};
```

データを更新しても、それ以前に取得したクエリのキャッシュデータは残ったままです。
クエリのキャッシュデータは、マウントされている全ての画面で利用されなくなった後、さらにcacheTime（デフォルト5分）が経過するまではそのまま利用されます。
このアプリではstaleTimeを0に設定しているため、こうしたデータはReact Queryによる次のrefetchのタイミングで更新されます。
しかし古いクエリキャッシュはなるべくすぐに無効化・更新することが望ましいです。

React Queryでは、クエリキャッシュを無効化する方法として、InvalidateとResetが用意されています。
Invalidateの場合は、古いデータを画面表示したまま、最新データを取得します。
Resetの場合は、古いデータを削除して画面表示されないようにした上で、最新データを取得します。
このアプリでは、Resetを用いて古いクエリキャッシュを無効化します。

このアプリでは、Mutation成功時に指定のQueryKeyのキャッシュをresetするWrapperを用意しています。
データの更新と同時に関連するクエリの古いキャッシュをリセットする場合のコード例は以下のようになります。

```typescript
import {useMutationWithResetQueries} from 'framework/backend';
import {getListTodoQueryKey, useListTodo, usePostTodo} from 'generated/sandbox/api';
import React, {useCallback, useState} from 'react';
import {View} from 'react-native';
import {Input, Button} from 'react-native-elements';

const SampleScreen: React.FC = () => {
  const [title, setTitle] = useState<string>();
  const listTodoQueryKey = getListTodoQueryKey();
  // 第一引数で指定したuseMutationの成功時に、自動的に第二引数で指定したQueryKeyのクエリキャッシュをリセットする
  const postTodo = useMutationWithResetQueries(usePostTodo, [listTodoQueryKey]);

  // (同様の処理)
};
```

### エラーハンドリング

TODO: デフォルトで設定済みのエラーハンドリングについて説明。
TODO: 各画面で個別に対応が必要なエラーハンドリングについて説明。
TODO: リトライについて説明。

## その他の外部サービスの呼び出し

Orvalによって自動生成されるのは、バックエンドAPIへのリクエスト用のCustom Hookのみです。
その他の外部サービスを利用する際には、各外部サービスが提供するSDKを別途利用します。
外部サービスがSDKを提供していない場合は、その外部サービスのOpenAPI Specificationを作成した上でOrvalによる自動生成を別途行います。
