---
title: ディープリンク受信時の画面遷移
---

Status: Accepted

<!--
Proposed: 提案中
Accepted: 採用
Rejected: 却下
Superseded: 廃止
-->

## 要約

- ディープリンクを受信した際の画面遷移に関する仕様は以下とする
  - 未認証時にディープリンクを受け取った場合は、ユーザが認証後、ディープリンクに対応した画面へ遷移させる
  - ディープリンクの遷移先画面で戻るボタンをタップ場合は、ディープリンクをタップする前に表示していた画面に戻す
    - ただし、ボトムタブを表示しているナビゲーターなど、通常のユーザ操作では前の画面に戻れないナビゲーターなどに遷移している場合は、前の画面に戻さない
- ディープリンクを受信した際の処理に、React Navigationの`linking`を使用しない

## コンテキスト

このアプリでは、ディープリンクを受信した際、URLに応じた画面へ遷移させます。

しかし、URLと画面のマッピングの管理や、クエリパラメータの取得、認証状態を考慮した画面遷移など、開発する上で考慮すべき事がたくさんあります。

ここではそれらの課題を解決するための方法を検討します。

## 議論

### ディープリンクを受信した際の画面遷移に関する仕様

このアプリでは、ディープリンクを受信した際、URLに応じた画面へ遷移させます。しかし、認証状態に応じた画面表示や、遷移先画面で戻るボタンをタップした場合はどの画面を表示すべきかなど、いくつか検討すべき点がありました。

#### 認証状態を考慮した画面制御

このアプリでは、認証状態によってユーザが閲覧可能な画面は異なります。ディープリンクに応じた遷移先画面が、未認証時に表示してはいけない画面である場合は、何もしない（ディープリンクに応じた画面へ遷移しない）ようにします。

次に、未認証時に受信したディープリンクの遷移先画面を、認証後に表示すべきかについて考えます。

認証後にディープリンクの遷移先画面を表示しないと、ユーザは本来到達したい画面に辿り着けない可能性があります。

また、辿り着けたとしても、ユーザ操作による画面遷移や再度ディープリンクをタップするなどの追加手順が必要だと、ユーザ体験としては好ましくありません。

そのため、未認証時に受け取ったディープリンクの遷移先画面を、認証後に表示します。

#### 遷移先画面で戻るボタンをタップした場合の動作

ディープリンクに応じた遷移先画面で戻るボタンをタップした場合の動作は、アプリによって様々です。このアプリでは、以下のような動作することがユーザにとって自然な動作であると考えました。

- 基本的には、ディープリンクをタップする前に表示していた画面に戻る
- ボトムタブを表示しているナビゲーターなど、通常のユーザ操作では前の画面に戻れないナビゲーターなどに遷移している場合は、前の画面に戻らない

### React Navigationの`linking`を使用した画面遷移

このアプリでは、ナビゲーションライブラリとして[React Navigation](https://reactnavigation.org/)を使用しています。React Navigationは、ディープリンクを受信した際、URLに応じた画面へ遷移する`linking`という機能を提供しています。

- [Deep linking](https://reactnavigation.org/docs/deep-linking/)
- [Configuring links](https://reactnavigation.org/docs/configuring-links/)

React Navigationの`linking`を使用することで、以下のようにURLと遷移先画面のマッピングを集約して管理できます。またURLを解析してくれるため、クエリパラメータやパスパラメータも取得できます。

```tsx
const config = {
  screens: {
    AuthenticatedStackNav: {
      screens: {
        QuestionDetail: {
          // URLのパスが「question/1234」の場合は、QuestionDetail画面に遷移し、パラメータとして「questionId=1234」を渡す
          path: 'question/:questionId',
        },
      },
    },
  },
}

const linking = {
  prefixes: ['https://example.com'], // <- このアプリで受け付けるURLのプレフィックス
  config,
};

return <NavigationContainer linking={linking}>{children}</NavigationContainer>
```

また、想定していないパスを受け取った場合のデフォルトの画面も指定できます。

```typescript
const config = {
  screens: {
    AuthenticatedStackNav: {
      screens: {
        QuestionDetail: {
          path: 'question/:questionId',
        },
      },
    },
    NotFound: '*', // <- 想定しないパスを受け取った場合はNotFound画面を表示する
  },
};
```

`initialRouteName`を指定することで、特定の画面を常にスタックの先頭に追加する機能などもあります。

```typescript
const config = {
  screens: {
    AuthenticatedStackNav: {
      // ディープリンクからQuestionDetail画面を直接開いても、戻るボタンタップ（navigation.goBack()）でHome画面に戻れる
      initialRouteName: 'Home',
      screens: {
        QuestionDetail: {
          path: 'question/:questionId',
        },
      },
    },
  },
};
```

このように、`linking`はディープリンクを処理する上で非常に便利な機能を提供してくれます。

一方で、認証状態を考慮した画面表示などいくつか検討が必要な点もあったため、以降ではそれらについて記載します。

#### 認証状態による画面表示の制御

React Navigationには、[認証フロー](https://reactnavigation.org/docs/auth-flow)に関するドキュメントがあります。しかし、`linking`と認証フローを組み合わせた場合のドキュメントはなく、以下のissueで議論されています。

- [Deep linking with Authentication Flow](https://github.com/react-navigation/react-navigation.github.io/issues/97)

##### 受け取ったディープリンクに応じた画面が、未認証で表示してはいけない場合の考慮

認証済の場合は、ディープリンクURLに応じて画面遷移するように、URLと遷移先画面のマッピングを定義します。

未認証の場合は、ディープリンクURLを無視して通常通り起動するように、マッピングは定義しません。

```typescript
// 認証済みの場合のみ、URLと遷移先画面のマッピングを定義
const config = isLoggedIn ? {
  screens: {
    AuthenticatedStackNav: {
      initialRouteName: 'Home',
      screens: {
        QuestionDetail: {
          path: 'question/:questionId',
        },
      },
    },
  },
} : undefined;
```

##### 未認証時に受け取ったディープリンクの遷移先画面を、認証後に表示する方法

この仕様を実現するための機能がReact Navigationには存在しません。そのため、以下の方法でこの機能を実現します。

- ディープリンクを受け取った時点で、そのディープリンクをグローバルなStateに保持
  - コールド、ウォームスタートの場合は、[linking.getInitialURL](https://reactnavigation.org/docs/navigation-container#linkinggetinitialurl)内でStateに設定
  - ホットスタートの場合は、[linking.subscribe](https://reactnavigation.org/docs/navigation-container#linkingsubscribe)内でStateに設定
- 認証後にStateからディープリンクを取得し、[Linking.openURL](https://reactnative.dev/docs/linking#openurl)を使用してそのディープリンクを開く
  - `Linking.openURL`を使用してアプリ内からディープリンクを開くことにより、`linking`に設定したURLと遷移先画面のマッピングに従って画面遷移が行われる

#### ディープリンクの遷移先画面で戻るボタンをタップした場合の動作

`linking`を使用して画面遷移する場合、`navigation.navigate`を使用した場合と同様の動作になります。

`navigation.navigate`は、[Moving between screens - Summary](https://reactnavigation.org/docs/navigating/#summary)に記載されている通り、以下の特徴を持っています。

- 対象の画面がナビゲーションスタック内に存在している場合は、その画面まで戻る
- 対象の画面がナビゲーションスタック内に存在していなければ、画面をスタックに追加する

そのため、ナビゲーションスタックの状態によっては、ディープリンクをタップする前に表示していた画面に`navigation.goBack`などで戻れません。

この挙動を回避する方法として、以下を検討しました。

- `linking.getActionFromState`を使用して、[Navigation action](https://reactnavigation.org/docs/navigation-actions)を設定する
- 遷移先画面の[Screen.getId](https://reactnavigation.org/docs/screen/#getid)で、ディープリンク受信時は常にユニークなIDを返却する

しかし、`linking.getActionFromState`は、React Navigationのドキュメントでは公開されておらず、積極的に使用するには不安が残ります。また、画面ごとにNavigation actionを変更する場合は、[Navigation state](https://reactnavigation.org/docs/navigation-state/)から画面を特定する必要があるため、コードが複雑化する可能性もあります。

`Screen.getId`からユニークなIDを返却する方法は、Navigation actionとして`RESET`が使えないため、以下の仕様を満たせない場合があります。

> ボトムタブを表示しているナビゲーターなど、通常のユーザ操作では前の画面に戻れないナビゲーターなどに遷移している場合は、前の画面に戻らない

詳細は、[React Navigationのlinkingの動作確認](./linking-feasibility)を参照してください。

### React Navigationの`linking`を使用しない場合の画面遷移

`linking`を使用しない場合は、ディープリンクの受信や、URLに応じた画面遷移などを自身で実装する必要があります。その反面、自由な画面遷移が実現可能です。

以下は、ディープリンク受信時の画面遷移を実現する例です。

ディープリンクの受信と、URLの解析には[Expo Linking](https://docs.expo.dev/versions/latest/sdk/linking/)を使用しています。

```tsx
type Props = {
  navigation: NavigationContainerRef<RootStackParamList>;
};

export const DeepLinkHandlers: React.FC<Props> = ({navigation}) => {
  // コールド・ウォームスタート
  useEffect(() => {
    Linking.getInitialURL().then(url => {
      if (url) {
        // ディープリンクを受信した場合は、アプリ内からディープリンクURLを開き、Linking.addEventListenerで再度受信する。
        // このように実装することで、アプリの初期画面が表示された後にディープリンクに応じた画面に遷移するため、
        // 遷移先画面から戻るボタンタップなどで、前の画面に戻ることができる。
        Linking.openURL(url);
      }
    });
  }, []);

  // ホットスタート
  useEffect(() => {
    const subscription = Linking.addEventListener('url', event => {
      const parsedURL = Linking.parse(event.url);

      if (parsedURL.path?.startsWith('screen-a')) {
        navigation.dispatch(StackActions.push('StackNavigator1', {screen: 'ScreenA'}));
      } else if (parsedURL.path?.startsWith('screen-b')) {
        navigation.navigate('StackNavigator1', {screen: 'ScreenB'});
      } else if (parsedURL.path?.startsWith('screen-d')) {
        navigation.dispatch(
          CommonActions.reset({
            index: 0,
            routes: [
              {
                name: 'TabNavigator2',
                state: {
                  index: 0,
                  routes: [{name: 'ScreenD'}],
                },
              },
            ],
          }),
        );
      }
    });
    return () => subscription.remove();
  }, [navigation]);

  return null;
};
```

ディープリンクの受信やディープリンクと遷移先画面のマッピングなど、`linking`に比べて実装する部分は多いのですが、それほどコードが複雑化することはない印象です。

ディープリンクの受信処理を自由に実装できるため、[ディープリンクを受信した際の画面遷移に関する仕様](#ディープリンクを受信した際の画面遷移に関する仕様)を全て満たすこともできます。

そのため、このアプリではReact Navigationの`linking`を使用しないで実装することにします。

:::note
未認証時に受け取ったディープリンクの遷移先画面を、認証後に表示する方法は、React Navigationの`linking`使用時に検討した方法と基本的には同じです。

- ディープリンクを受け取った時点で、そのディープリンクをStateに保持
  - コールド、ウォームスタートの場合は、[Linking.getInitialURL](https://docs.expo.dev/versions/latest/sdk/linking/#linkinggetinitialurl)内でStateに設定
  - ホットスタートの場合は、[Linking.addEventListener](https://docs.expo.dev/versions/latest/sdk/linking/#linkingaddeventlistenertype-handler)内でStateに設定
- 認証後にStateからディープリンクを取得し、[Linking.openURL](https://docs.expo.dev/versions/latest/sdk/linking/#linkingopenurlurl)を使用してそのディープリンクを開く
  - `Linking.openURL`を使用してアプリ内からディープリンクを開くことにより、`Linking.addEventListener`でディープリンクを再度受信する
:::

## 決定

- ディープリンクを受信した際の画面遷移に関する仕様は以下とする
  - 未認証時にディープリンクを受け取った場合は、ユーザが認証後、ディープリンクに対応した画面へ遷移させる
  - ディープリンクの遷移先画面で戻るボタンをタップ場合は、ディープリンクをタップする前に表示していた画面に戻す
    - ただし、ボトムタブを表示しているナビゲーターなど、通常のユーザ操作では前の画面に戻れないナビゲーターなどに遷移している場合は、前の画面に戻さない
- ディープリンクを受信した際の処理に、React Navigationの`linking`を使用しない
