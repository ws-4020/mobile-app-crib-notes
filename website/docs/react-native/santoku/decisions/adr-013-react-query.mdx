---
title: React Queryを用いた開発方針
---

Status: Proposed

<!--
Proposed: 提案中
Accepted: 採用
Rejected: 却下
Superseded: 廃止
-->

## 要約

React Queryを用いた開発方針は以下とします。

- React Queryのデフォルトオプションについて、クエリオプションの`retry`を`false`に設定する以外はデフォルトのままとする
- データ更新後に古くなったキャッシュデータを破棄し、で古いデータを表示させない
- 二重送信防止のためユーザ操作に応じた操作制限を実施する
- React QueryのGlobal callbacks機能を利用して共通エラー処理を実現する
- `useQuery`および`useMutation`をラップしたフックを用意し、その中で通信リトライを実現する
- ページネーションや無限スクロールに対応したバックエンドAPIの仕様をアプリ内で統一する
- クライアントコードの自動生成ツールにOpenAPI Generatorを採用する

## コンテキスト

React Queryは非常に豊富な機能を用意したデータフェッチ用ライブラリです。
React Queryを用いることで、HTTP API通信を実現する上での様々な課題が解決します。
しかしながら、全ての課題が解決するわけではありません。
例えば次のような開発課題については、それぞれのアプリの特性に応じて決定する必要があります。

- React Queryのデフォルトオプションとして何を設定すべきか
- データ更新時で古くなったキャッシュデータをどのように扱うか
- 二重送信防止について
- エラーハンドリングについての実装方針
- ページネーションや無限スクロールへの対応方針
- クライアントコードの自動生成について
- クエリーキーの設定ルールをどうするか

ここでは、上記課題解消を目的として、React Queryを用いた開発方針について検討します。

## 議論

### React Queryのデフォルトオプション

#### クエリのデフォルトオプション

React Queryには多数のオプションが用意されております。
これらのオプションは、全てのクエリで有効な値を設定することが出来、かつクエリ毎にその値を上書きできます。
ここでは、これらいくつかのオプションについて、このアプリの特性に応じた設定値を検討します。
特に、React Query公式ドキュメントの[Important Defaults](https://react-query.tanstack.com/guides/important-defaults)で示されるオプションについては、デフォルトのままで問題ないかを注意深く検討します。

|オプション|検討結果|
|:--|:--|
|queryFn|[Default Query Function](https://react-query.tanstack.com/guides/default-query-function)で紹介されているとおり、デフォルトのクエリ関数を定義出来ます。これにより、SWRのようなシンプルな記述を実現することが出来ます。しかしながら、このアプリではOpenAPI仕様からソースコードを自動生成することにより、REST APIとの整合性や開発効率性の向上を図ります。その為、このオプションは利用しません。|
|retry|クエリ失敗時のリトライ回数です。[Important Defaults](https://react-query.tanstack.com/guides/important-defaults)で示されるとおり、デフォルト値は3です。このアプリでは、[HTTP API 通信のリトライ](../application-architecture/http-api/http-api-error-handling.mdx#http-api通信のリトライ)に従いリトライはユーザ自身の判断とします。`false`をデフォルト値として設定します（リトライしません）。|
|retryOnMount|マウント時にリトライするかどうかを示します。デフォルト値は`true`です。デフォルト値のままとします。|
|retryDelay|リトライ時の遅延間隔を示します。デフォルトでは、リトライの度に指数関数的に待ち時間が増えていきます（Exponential Backoff）。デフォルト値のままとします。|
|staleTime|クエリが「新しい」ものから「古くなる」までの期間です。[Important Defaults](https://react-query.tanstack.com/guides/important-defaults)で示されるとおり、デフォルト値は0です。デフォルト値のままとし、必要に応じて各クエリ毎に個別で設定することとします。|
|cacheTime|未使用なクエリを削除するまでの期間です。[Important Defaults](https://react-query.tanstack.com/guides/important-defaults)で示されるとおり、デフォルト値は5分です。デフォルト値のままとし、必要に応じて各クエリ毎に個別で設定することとします。|
|refetchOnMount|マウント時に再フェッチするかどうかを示します。デフォルト（`true`）では、データが古くなっている場合に再フェッチします。デフォルト値のままとします。|
|refetchOnWindowFocus|ウィンドウフォーカス時に再フェッチするかどうかを示します。デフォルト（`true`）では、データが古くなっている場合に再フェッチします。デフォルト値のままとします。|
|refetchOnReconnect|再接続時に再フェッチするかどうかを示します。デフォルト（`true`）では、データが古くなっている場合に再フェッチします。デフォルト値のままとします。|
|structuralSharing|デフォルト（`true`）では、クエリ結果のデータの中身が変更されていない場合、データの参照が変更されません。これによりアプリのパフォーマンス向上が望めます。デフォルト値のままとしますが、クエリ結果の比較がパフォーマンス上の問題を引き起こす場合は、個別で`false`に設定こととします。|

#### ミューテーションのデフォルトオプション

クエリ同様、ミューテーションにおいても全てのミューテーションで有効な値を設定することが出来ます。
検討の結果、ミューテーションにおいてはデフォルトオプションは必要ないと判断しました。

#### デフォルトオプションの設定例

上記検討結果を反映したデフォルトオプションの設定例は次の通りです。

```typescript jsx
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  });
```

### データ更新時のキャッシュの扱いについて

React Queryでは、クエリは取得済みのデータを返し必要に応じてバックグラウンドで再フェッチします。
これは頻繁なローディングインジケーターの表示を抑えUX向上に役立ちます。
一方で、更新後も一時的に古いデータが見えるデメリットがあります。

React Queryの公式ドキュメントでは、データ更新時にデータを最新化する2つの方法が提示されています。

1. [Invalidation from Mutations](https://react-query.tanstack.com/guides/invalidations-from-mutations)
2. [Updates from Mutation Responses](https://react-query.tanstack.com/guides/updates-from-mutation-responses)

1つめは、ミューテーション成功時にキャッシュしたクエリを無効にする方法です。
これにより、対象となるクエリはバックグラウンドで再フェッチを試みます。
この方法は再フェッチが終了するまで一時的に古いデータが表示されるため、ユーザの混乱を引き起こす可能性があります。

2つめは、ミューテーション成功時にレスポンスの値でキャッシュデータを更新する方法です。
パフォーマンスに優れた方法ですが、レスポンスで更新後の値を取得できることが前提となります。
また、やや実装が複雑となります。

このアプリにおいては、更新後に古いデータが見えることなく、かつできるだけシンプルな方法でデータを最新化したいです。
そこで、ミューテーション成功時に再フェッチが必要なクエリのキャッシュデータを破棄することで、古いデータを表示させない方針とします。コード例は次の通りです。

```typescript jsx
const mutation = useMutation(addTodo, {
  onSuccess: () => {
    queryClient.resetQueries('todos');
  },
});
```

このコードでは、新しいタスクを追加した後にToDoリストのキャッシュデータを破棄します。
これにより再フェッチ中は画面にローディングインジケーターが表示されることとなりますが、古いデータが表示されることはありません。

### 二重送信防止について

Webアプリケーション同様に、モバイルアプリにおいても二重送信を防ぐ仕組みが必要です。
しかし、商品購入のような重要操作の二重実行を完全に防ぐ為には、バックエンド側での対策（トークンを用いたチェックなど）が必要です。
バックエンド側の対策はここでの検討範囲外とし、更新ボタンの二重押下のような、ユーザの操作ミスによる二重送信を防ぐための対策を検討します。

対策として、次の案があります。

- 送信（ローディング）中も一切の操作を制限しない
- 送信（ローディング）中は対象ボタンのみを押下不可
- 送信（ローディング）中は対象画面全体を操作不可（画面遷移は可能）
- 送信（ローディング）中はアプリ全体を操作不可（画面遷移は不可能）

下の案にいくほどユーザ操作が制限されるため、ユーザビリティが落ちます。
一方で、下の案ほどユーザ操作を制限できるため、予期せぬ操作への考慮が不要となります。

一般的に参照操作に比べて更新操作はそれほど多くありません。
その為、更新中の操作を制限することはそれほどユーザビリティに影響を与えないと判断し、このアプリにおいては次の方針とします。

- 初期ロードなどの参照操作については、一切の操作を制限しない
- 検索ボタン押下などの参照操作については、対象ボタンのみを押下不可とする
- ユーザ設定更新のような再実行可能な更新操作については、対象ボタンのみを押下不可とする
- 商品購入のような重要操作については、アプリ全体を操作不可とする

### エラーハンドリング

[HTTP API 通信で発生するエラーのハンドリング](../application-architecture/http-api/http-api-error-handling.mdx)に従います。
それぞれのエラーハンドリングは個別で実装せずに処理の共通化を検討します。
また、HTTPステータスコード401が返却された場合の通信リトライについても処理の共通化を検討します。

#### エラーハンドリングの共通化

`useQuery`のクエリオプションである`onError`にエラーハンドラ関数を設定することで、クエリで発生したエラーをハンドリングできます。
また、`QueryClient`のデフォルトオプションに設定することで、各クエリ毎にエラーハンドラ関数を設定する手間が省けます。
しかしならが、上記方法だと次の課題が発生します。

- 個別にエラー処理を追加したい場合、`useQuery`の`onError`に独自のエラーハンドラ関数を設定すると、`QueryClient`のデフォルトオプションに設定したものが上書きされる
- 同じクエリを使用した画面が複数存在すると、エラー処理も複数回実行される（例えばトーストが複数表示される）

そこで、共通のエラーハンドラ関数は`QueryCache`の`onError`に設定することとします。
そうすることで、上記に挙げた課題が解決します。
ミューテーションについても同様の対策とします。
詳細は次のドキュメントを参照してください。

- [QueryCache - Global callbacks](https://react-query.tanstack.com/reference/QueryCache#global-callbacks)
- [MutationCache - Global callbacks](https://react-query.tanstack.com/reference/MutationCache#global-callbacks)

#### HTTPステータスコード401返却時の通信リトライ

HTTPステータスコード401が返却された場合、新しいセッションIDを再取得しリトライする必要があります。
React Queryにも通信リトライ機能は用意されておりますが、一時的なネットワークエラーに対応するものであり、セッションの再接続などは実現できません。そこで、`useQuery`および`useMutation`をラップしたフックを用意し、渡された非同期関数にリトライ機能を追加することで実現します。実装イメージは次の通りです。

```typescript jsx
export function useWrappedQuery(queryKey, queryFn, options) {
  return useQuery(queryKey, withRetry(queryFn), options);
}
```

### ページネーションや無限スクロールへの対応

リモートにある膨大なデータからアプリ内で必要なデータのみを取得し表示するには、ページネーションや無限スクロールへの対応が必要です。
React Queryにはページネーションや無限スクロールの仕組みが用意されているのでそれに従います。

- [Paginated / Lagged Queries](https://react-query.tanstack.com/guides/paginated-queries)
- [Infinite Queries](https://react-query.tanstack.com/guides/infinite-queries)

ここでは、ページネーションや無限スクロールを実現するために必要なバックエンドAPIの仕様について検討します。
バックエンドAPIの仕様はアプリ内で統一することとします。

#### ページネーション

ページネーションを実現する為には、バックエンドAPIのリクエスト項目にページ番号が必要です。
さらにはページサイズやソート順を指定できるのが望ましいです。
また、全ページ数を表示するにはレスポンスにその値が必要です。

ページネーションを実現するにあたり、標準的な仕様は特に見当たりませんでした。
そこで、[Spring Data REST Reference Guide の 5. Paging and Sorting](https://docs.spring.io/spring-data/rest/docs/current/reference/html/#paging-and-sorting)を参考に次の通りとします。

| URLクエリパラメータ  | 説明           | 必須 |
| :------------------- | :------------- | :--- |
| page                 | 開始ページ番号 | ○    |
| size                 | ページサイズ   |      |
| sort                 | ソート項目     |      |

トータル件数は、HTTPボディの`page`オブジェクトの項目として返却します。

| `page`オブジェクトの項目 | 説明             | 必須 |
| :----------------------- | :--------------- | :--- |
| totalElements            | トータル件数     | ○    |
| totalPages               | トータルページ数 | ○    |

#### 無限スクロール

無限スクロールを実現する為には、カーソル（ソート可能なID）が必要です。
さらには最大取得件数を指定できるのが望ましいです。
また、レスポンスには次のデータ位置を指し示すカーソルが必要です。

無限スクロールを実現するにあたり、標準的な仕様は特に見当たりませんでした。
そこで、[Infinite Queries](https://react-query.tanstack.com/guides/infinite-queries)のサンプルコードを参考に次の通りとします。

| URLクエリパラメータ  | 説明         | 必須 |
| :------------------- | :----------- | :--- |
| cursor               | カーソル     | ○    |
| limit                | 最大取得件数 |      |

次のデータ位置を指し示すカーソルは、HTTPボディの項目として返却します。
次のカーソルがない場合はnullを返却します（※1）

| HTTPボディの項目  | 説明         | 必須 |
| :---------------- | :----------- | :--- |
| nextCursor        | 次のカーソル | ※1   |

### クライアントコードの自動生成について

REST APIの仕様がOpenAPIとして定義されていると、その定義からクライアントコードを自動生成できます。
そうすることで、定型作業による作業時間を排除し、また作業ミスを減らすことで品質向上が期待できます。

このアプリにおいてもバックエンドAPIの仕様がOpenAPIとして定義されています。
これを用いてクライアントコードの自動生成について検討します。

React Queryを使う場合の自動生成ツールとして次の候補があります。

- [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator)
- [Orval](https://orval.dev/)

それぞれにおいて比較検討しました。
比較結果は次のとおりです。

|     | OpenAPI Generator | Orval |
| :-- | :-- | :-- |
| ライセンス | Apache License 2.0 | MIT License |
| 開発母体 | OpenAPI Tools | 個人 |
| 人気 | 11k star(GitHub) | 367 star(GitHub) |
| 機能 | 〇  | 〇 |
| 実績 | ◎ | △ |

#### ライセンス

OpenAPI GeneratorのライセンスはApache License 2.0です。
OrvalのライセンスはMIT Licenseです。
いずれも商用利用において問題ありません。

#### 開発母体

開発母体はOpenAPI GeneratorがOpenAPI Toolsという組織での開発に対し、Orvalは個人が開発しています。
OpenAPI Generatorのほうが開発母体として安定性を感じます。

#### 人気

GitHubのスターで確認する限り、OpenAPI Generatorのほうが圧倒的に知名度があります。

#### 機能

OpenAPI GeneratorはFetch APIやaxiosを使用したクライアントコードを自動生成できます。
一方で、まだReact Queryは対応していないようです。
そのため、API毎に`useQuery`を使用したカスタムフックは用意する場合、別途実装する必要があります。
OrvalはReact Queryにも対応しており、API毎に`useQuery`を使用したカスタムフックが自動生成されます。

#### 実績

定量的な数値は抑えておりませんが、OpenAPI Generatorを用いた開発実績は多数あります。

#### 比較検討結果

HTTP API通信を実装するにあたり、いくつかのデータフェッチ用ライブラリを比較検討しました。
検討の結果、開発母体および実績を主な理由としてOpenAPI Generatorを採用します。

## 決定

React Queryを用いる上での開発方針について検討しました。
このアプリでは、以下それぞれの課題に対して次の方針をとります。

| 課題 | 結論 |
|:--|:--|
|React Queryのデフォルトオプションとして何を設定すべきか|クエリオプションの`retry`を`false`に設定する以外はデフォルトのままとします。|
|データ更新時で古くなったキャッシュデータをどのように扱うか|データ更新後に古くなったキャッシュデータを破棄することで古いデータを表示させません。|
|二重送信防止について|ユーザ操作に応じた操作制限を実施します。|
|エラーハンドリングについての実装方針|React QueryのGlobal callbacks機能を利用して共通エラー処理を実現します。また、`useQuery`および`useMutation`をラップしたフックを用意し、その中で通信リトライを実現します。|
|ページネーションや無限スクロールへの対応方針|バックエンドAPIの仕様をアプリ内で統一します。|
|クライアントコードの自動生成について|開発母体および実績を主な理由としてOpenAPI Generatorを採用します。|
|クエリーキーの設定ルールをどうするか||
