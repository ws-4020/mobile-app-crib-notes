---
title: React Navigationのlinkingの動作確認
---

### `linking`のデフォルト動作の確認

`linking`を使用して画面遷移する場合、`navigation.navigate`を使用した場合と同様の動作になります。

`navigation.navigate`は、[Moving between screens - Summary](https://reactnavigation.org/docs/navigating/#summary)に記載されている通り、以下の特徴を持っています。

- 対象の画面がナビゲーションスタック内に存在している場合は、その画面まで戻る
- 対象の画面がナビゲーションスタック内に存在していなければ、画面をスタックに追加する

ナビゲーションスタックの状態によっては、ディープリンクをタップする前に表示していた画面に`navigation.goBack`などで戻れない事が予想できます。

以下に例を記載します。

ユーザは、アプリで`ScreenC`を表示しています。

```markdown title=ナビゲーションスタック（ディープリンクタップ前）
- StackNavigatorA
  - ScreenA
  - ScreenB
  - ScreenC <- この画面が表示されている
```

ユーザが`ScreenB`に遷移するディープリンクをタップすると、スタック内に既に存在する`ScreenB`まで戻ります。

```markdown title=ナビゲーションスタック（ディープリンクタップ後）
- StackNavigatorA
  - ScreenA
  - ScreenB <- この画面が表示されている
```

この場合、`ScreenB`から`navigation.goBack`を実行した場合、`ScreenA`に戻ってしまいます。

もう1つ例を記載します。

ユーザは、アプリで`StackNavigatorB`内の`ScreenF`を表示しています。

```markdown title=ナビゲーションスタック（ディープリンクタップ前）
- StackNavigatorA
  - ScreenA
  - ScreenB
  - ScreenC
- StackNavigatorB
  - ScreenD
  - ScreenE
  - ScreenF <- この画面が表示されている
```

ユーザが`ScreenB`に遷移するディープリンクをタップすると、まず`StackNavigatorA`まで戻ります。その後、`StackNavigatorA`のスタック内に存在する`ScreenB`まで戻ります。

```markdown title=ナビゲーションスタック（ディープリンクタップ後）
- StackNavigatorA
  - ScreenA
  - ScreenB <- この画面が表示されている
```

この場合、`ScreenB`から`navigation.goBack`を実行した場合、`ScreenA`に戻ってしまいます。

これらの挙動を回避する方法として、以下を検討しました。

- `linking.getActionFromState`を使用して、Navigation actionを設定する
- 遷移先画面の`Screen.getId`で、ディープリンク受信時は常にユニークなIDを返却する

### `linking.getActionFromState`を使用して、Navigation actionを設定する

`linking.getActionFromState`は、[Navigation action](https://reactnavigation.org/docs/navigation-actions)を設定するための関数です。引数で、[Navigation state](https://reactnavigation.org/docs/navigation-state/)を受け取るため、画面に応じてNavigation actionを設定できます。

```tsx
import {NavigationContainer, getActionFromState as getOriginalActionFromState} from '@react-navigation/native';

const getActionFromState: typeof getOriginalActionFromState = useCallback((state, options) => {
  const action = getOriginalActionFromState(state, options);
  // 画面に応じてNavigation actionを設定
  if (ScreenAの場合) {
    return {...action, type: 'PUSH'};
  } else if (ScreenBの場合) {
    return {...action, type: 'NAVIGATE'};
  } else {
    return {...action, type: 'RESET'};
  }
}, []);

const linking = {
  ...
  getActionFromState,
};

return <NavigationContainer linking={linking}>{children}</NavigationContainer>;
```

しかし、`linking.getActionFromState`は、React Navigationのドキュメントでは公開されておらず、積極的に使用するには不安が残ります。また、Navigation stateの構造は複雑であるため、遷移先画面に応じた条件分岐の作成は難しくなると考えられます。

:::note
`linking`には、[Advanced cases](https://reactnavigation.org/docs/configuring-links#advanced-cases)に記載されているように、[linking.getStateFromPath](https://reactnavigation.org/docs/navigation-container#linkinggetstatefrompath)という機能もあります。

この機能を使用することにより、URLからNavigation stateの状態を自由に作成できます。

そのため、`linking.getActionFromState`と`linking.getStateFromPath`を組み合わせることで、自由度の高い画面遷移が実現可能です。

しかし、これらの実装は非常に複雑な処理になることが予想されます。URLの解析やNavigation stateの生成を自身で実装することは、`linking`を使うことで得られる多くのメリットを失います。
:::

### 遷移先画面の`Screen.getId`で、ディープリンク受信時は常にユニークなIDを返却する

`navigation.navigate`は、[Screen.name](https://reactnavigation.org/docs/screen/#name)と[Screen.getId](https://reactnavigation.org/docs/screen/#getid)の返却値によって、画面遷移の挙動が変わります。

同一の`name`と`getId`の返却値を持つScreenがナビゲーションスタックに存在している場合、その画面まで戻ります。そうではない場合、画面をナビゲーションスタックに追加します。

この特徴を利用して、ディープリンク受信時は`getId`からユニークなIDを返却することで、`navigation.push`と同様の挙動を実現できます。

```tsx
// クエリパラメータとして、linking=trueを受け取った場合は、ユニークなIDを返却する
export const RootStackNavigator: React.FC = () => {
  return (
    <nav.Navigator>
      <nav.Screen
        name="StackNavigatorA"
        component={StackNavigatorA}
        getId={({params}) => {
          if (params?.screen === 'ScreenB') {
            return params.params?.linking ? String(Date.now()) : undefined;
          }
          return undefined;
        }}
      />
    </nav.Navigator>
  );
};

const StackNavigatorA: React.FC = () => {
  return (
    <nav.Navigator>
      <nav.Screen name="ScreenA" component={ScreenA} />
      <nav.Screen
        name="ScreenB"
        component={ScreenB}
        getId={({params}) => (params.linking ? String(Date.now()) : undefined)}
      />
      <nav.Screen name="ScreenC" component={ScreenC} />
    </nav.Navigator>
  );
};
```

しかし、この方法の場合は、Navigation actionとして`NAVIGATE`と`PUSH`以外のものを使用できません。

:::note
`Screen.getId`を使用してNavigation actionを`PUSH`に変更する方法は、以下のissueで議論されています。

- [Linking for stack to call 'push' action instead 'navigate'](https://github.com/react-navigation/react-navigation/issues/9090)

:::
