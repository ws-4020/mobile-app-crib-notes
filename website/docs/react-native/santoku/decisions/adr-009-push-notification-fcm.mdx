---
title: FCMを用いたプッシュ通知の管理方針
---

Status: Proposed

<!--
Proposed: 提案中
Accepted: 採用
Rejected: 却下
Superseded: 廃止
-->

## 要約

:::note
ADRの決定事項を要約して、3行程度で記載してください。
:::

<!--
決めるポイント

- ログアウト中のユーザに時間割開始通知は届けるべき？届けないべき？
  - 届けない方がよいのでは。
  - 登録トークンをバックエンドから削除することで届かないようにするのがシンプルになりそう。

- iOS端末での通知許可確認ダイアログの表示タイミング
  - 一旦、方式設計段階のデモとしては、サインアップ完了後に通知許可ダイアログを表示する。
  - 今回のサンプルアプリでは特に通知の目的を説明する画面までは用意せず、ADRでこういうことも検討した方が良いと記載するに留める。
    - 具体的にどうするかは個別のアプリ実装時に検討してもらうものとする。

- 登録トークンの登録・更新タイミング
  - サンプルアプリではログアウト中のユーザには通知せずトークンを保持しないので、少なくともログイン完了以降である必要がある。
  - ログイン完了時に登録するものとする。
  - ログイン完了時にクライアント側でトークンが無いか無効になっていたりバックエンド側でトークンを保持していなければ再登録する
    - この時、アプリの通知設定がOffで、Offだとトークンを生成できなかったらどうする？
      - この時点では登録できなくてよいが、どこかで通知設定がONになったことを検出し、そのタイミングで生成・バックエンドへの登録を行わないといけない
  - 同じくログイン完了時に、トークンの生成日時を見て定期更新が必要か判断し、更新が必要なら再登録する
    - 以前のトークン生成日時はバックエンド側から取得する
      - クライアント側からアカウント情報を取得するAPIで、現在そのアカウントに登録されているトークンと生成日時の一覧を一緒に返す
      - 端末の時刻と比較することになるが、端末時刻は信用してよいか？
        - 日付が未来日になっていて余計に再登録されることには害がない
        - 日付が過去日になっていて定期更新がされないと問題が生じる場面はあるかも

- 登録トークンの保存形式
  - 登録トークンとタイムスタンプとセットでデータベースに保存
  - 保存場所はH2のデータベース
    - アカウントとFCMトークンを紐づけるテーブルを用意する (1アカウントに対しnトークン（今回はnにできないけど）)
    - 属性は、アカウントID, FCMトークン, 生成日時

- 登録トークンの削除タイミング
  - トークンが無効になっていたら消す
  - ログアウト時にも通知が届かないようにするため削除する
  - 通知がOffに変更されている場合は消さない
    - => そもそもOffになっている場合、消すべき登録トークンをクライアント側で取得できるのか？これがわからないとそもそも消せない。
      - => 検証する。
    - => もし取得できたとして、消す？
      - => 消してしまうと、通知ONの場合に再登録する必要が出てくる
      - => しかし通知ONになったことを常時監視し続けたくはない
      - => 今回は通知Offになった場合に消さないでおいて、通知Offの相手にも通知を送信し続けるものとする。
        - => 通知Offの相手に通知を送信した場合のバックエンドへのレスポンスと端末側の挙動を確認しておく

- 登録トークンの定期更新をやるか
  - ベストプラクティスに沿ってやった方がよさそうなのでやる
  - クライアント側で、アカウント情報と一緒に受け取ったトークンの生成日時を見て更新の必要性を判断する

- 通知に含めるデータ形式
  - 通知のタイプとパラメータをデータに含められるようにする。クライアント側はそのタイプとパラメータを見て必要なアクションをとる
    - 画面遷移が必要なら画面遷移させる
    - 将来的には、何かダイアログを出すようなケースもあるかも？

```
{
  "type": "StartTimeTable",
  "params": {
    "teamId": 123,
    "timetableId": 456,
  }
}
```
-->

## コンテキスト

:::note
この決定や変更をしなくてはいけない状況や問題などを説明してください。
:::

次の観点でFCMを用いたプッシュ通知の管理方針について議論・調査を進めていきます。

- デバイス登録トークンの管理
- レート制限
- エラーハンドリング

## 議論

### 登録トークンの管理

[FCM登録トークン管理のベストプラクティス](https://firebase.google.com/docs/cloud-messaging/manage-tokens)が公式のドキュメントとして用意されています。
サンプルアプリケーションでも原則このベストプラクティスに従うものとします。

#### 登録トークンの保存

各デバイスの登録トークンは、バックエンドサーバに保存します。
この際に、登録トークンに加えて、登録トークン生成日時のタイムスタンプもあわせて保存しておきます。
登録トークン生成日時を保存しておくことで、登録トークンの定期更新が必要か判断する基準にできます。

デフォルトでは、FCM SDKはアプリの起動時にクライアントアプリのインスタンスの登録トークンを生成します。
またそのタイミングでライブラリによりそのIDと構成データがFirebaseにアップロードされます。
サンプルアプリケーションでも、登録トークンの生成とFirebaseへの登録はFCM SDKのデフォルトにあわせてアプリの起動時に行います。
この時点でFirebaseへのデバイス登録は行われますが、まだバックエンドサーバ側では登録トークンを保持していないため、通知の送信対象にはしません。

サンプルアプリケーションではログインしていないデバイスへは通知を送信しません。
そのため、バックエンド側ではログイン中のデバイスの登録トークンのみを保持します。
そのためアプリ起動時ではなく、デバイス側でログインが完了したタイミングで登録トークンをAPIを通じてバックエンドサーバへ保存します。

iOS端末の場合、登録トークンを利用して通知を送信するためには、このアプリからの通知の送信を許可するか確認するダイアログを表示し、許可を取る必要があります。
このダイアログも同じくログインが完了したタイミングで表示します。
ここで通知の送信をユーザが拒否した場合は、登録トークンのバックエンドサーバへの保存は行わないものとします。

:::info
iOS端末の場合、通知機能を利用する前にアプリ内で通知送信の許可を求めるダイアログを表示し、ユーザの意思を確認する必要があります。
それをユーザが拒否した場合、以降アプリ内では許可を求めるダイアログを再表示できず、
ユーザがOSの設定からアプリの通知をオンに設定しない限り通知機能は利用できません。

しかし少なくないユーザは、通知が何の目的で用いられるのか説明される前に許可を求めるダイアログが表示されると、許可しないを選択します。
これはユーザの体験を向上させる目的で通知機能を提供しているアプリにとって不幸なすれ違いです。

サンプルアプリケーションではログイン直後に説明なく通知の許可を求めるダイアログを表示していますが、
実際のアプリケーションではよりユーザが納得しやすい形で許可を求めるべきです。
この問題を改善するために、例えば以下のような方法を採用できます。

#### プッシュ通知が本当に必要になるタイミングで通知許可を要求する

例えば、特定の条件を満たした場合に通知を受け取るという設定がアプリ内に存在するとします。
この設定をオンに設定したタイミングで通知許可ダイアログを表示した場合、ユーザはこの通知を受け取るために通知の許可を要求しているのだと明確に理解できます。

#### プッシュ通知の目的を説明する画面を用意し、その画面で通知の目的に同意したユーザにのみiOSの提供する通知許可ダイアログを表示する

iOSが用意している通知許可ダイアログは一度しか表示できません。
そのため何度でも表示できる別の画面で一度ユーザの意向を確認した上で、同意してくれたユーザにのみiOSの提供する通知許可ダイアログを表示します。
用意した画面で同意しなかったユーザに対しても、後からいつでもその画面に遷移して通知を許可できるようにします。

#### アプリからOSの通知設定画面へ誘導する

一度iOSの通知許可ダイアログで拒否された場合、OSのアプリ設定の画面からしか通知設定は変更できません。
通知を有効化する方法をアプリ内で説明し、アプリ設定画面を開くためのボタンなどを用意しておくことで、設定を変更してもらえる可能性が高まります。
ただし、ユーザの意思を尊重せずに通知の有効化を強要するようなデザインにしてしまうと、ストア公開審査時に規約違反と判断される可能性があります。
:::

#### 登録トークンの保存形式

先述のとおり、登録トークンとタイムスタンプをセットでバックエンドサーバのデータベースに保存します。

今回は登録トークンを保存するタイミングがログイン完了後であるため、その時点で対象アカウントも特定できています。
そのため、アカウントID、登録トークン、登録日時を組として保存するテーブルを1つ設けるものとします。

このテーブルでは、一人のユーザが複数のデバイスを利用する可能性があることを考慮し、1アカウントに対し複数の登録トークンを保存できるようにします。
今回のサンプルアプリケーションでは1つのデバイスで複数のアカウントを同時に利用することは考慮しておらず、アカウントを切り替える際には必ずログアウトを行います。
ログアウト時には登録トークンを削除するため、1つの登録トークンが複数のアカウントで同時に利用されることは考慮しません。

登録日時のタイムスタンプをどのような形式で保存するかは、日時の取り扱いに関するアプリの方針に従うものとします。
登録日時は保存する際のバックエンドサーバ側日時を保存するものとします。

#### 登録トークンの更新

デバイスの登録トークンは以下の場合などに変更される可能性があります。

- アプリが元のデバイスから新しいデバイスに復元される
- ユーザがアプリをアンインストールまたは再インストールする
- ユーザがアプリデータをクリアする

初回起動時と同様、この場合もFCM SDKはデフォルトでは次回のアプリ起動時に登録トークンを生成します。
またそのタイミングでライブラリによりそのIDと構成データがFirebaseにアップロードされます。

サンプルアプリケーションでは、ログイン（自動ログイン含む）完了時に登録トークンの変更がないか確認するものとします。
バックエンド側にデバイスの登録トークンが登録されていなかった場合、新しい登録トークンをバックエンドサーバに保存します。
iOSの通知送信許可を求めるダイアログも、再インストールなどにより再表示可能になっていればこのタイミングで表示します。

また、後述する登録トークンの削除のタイミングでは、バックエンドサーバから登録トークンを削除します。
バックエンドサーバ上で登録トークンが削除されていた場合も同様に、登録トークンを再生成してバックエンドサーバに保存します。

また登録トークンが無効化された場合だけでなく、登録トークン生成日時をもとに定期的に登録トークンを更新します。
登録トークンを定期的に更新することで、アプリが起動されなくなり更新されなくなった古い登録トークンを判別できるようになります。
これにより、アプリが起動されなくなったデバイスをプッシュ通知の送信対象から除外できます。
これは、大量のデバイスへ通知を送信するユースケースでのレート制限の回避やパフォーマンス改善につながります。

FCMでは、月に1度程度登録トークンを更新し、生成から2か月以上経過した古い登録トークンに対し、デバイス登録解除やトピック購読解除を行うことを推奨しています。
サンプルアプリケーションでもそれに倣い、月に1度登録トークンを更新し、生成から2か月以上経過した古い登録トークンのデバイス登録を解除するものとします。

#### 登録トークンの削除

FCMは、無効なトークンに対する通知送信リクエストを受け取った場合に、以下のエラー応答を返します。

- UNREGISTERD (HTTP 404)
  - 指定した登録トークンがそのアプリに対して登録されていない場合に返されます
- INVALID_ARGUMENT (HTTP 400)
  - リクエストパラメータに問題がある場合に返されます
  - 登録トークンが問題の原因である場合は、Invalid registrationという理由が返されます

UNREGISTERDが返された場合は登録トークンが無効であるため、バックエンドサーバから登録トークンを削除します。
またINVALID_ARGUMENTが返されて理由がInvalid registrationだった場合も同様に登録トークンを削除します。

また、今回のサンプルアプリケーションではログインしている端末にのみ通知を送信したいため、ログアウト時にもバックエンドサーバから登録トークンを削除します。

その他の削除タイミングとして、アプリの設定で通知設定がOffに変更されたタイミングも挙げられます。
このタイミングで削除する場合、次に通知設定がOnに変更されたことを検出し、そのタイミングで登録トークンをバックエンドサーバに再保存する必要があります。
サンプルアプリケーションでは、処理が複雑になることを避けるため、通知設定がOffに変更されたタイミングでは登録トークンを削除しないものとします。

<!--
TODO: OSのアプリ設定で通知がOffに設定されている場合にFCM登録トークンは取得できるのか、Android/iOSで検証。

これができないと登録トークンが変更されていないかの確認や定期更新に差し支えるので、
通知Onになったタイミングをどうにかして検出する必要が出てくる。

Stack Overflowの質問を見た範囲では、iOSの通知許可ダイアログで許可を得なくてもFCM登録トークン自体は生成・取得できるが、
実際にそのトークンへ送信しようとすると権限がないというエラーがAPNsから返ってくる挙動のようにみえるので、おそらく大丈夫だとは思われる。
-->

### レート制限

FCMでは、プッシュ通知の送信レートの制限が設けられています。
また、FCMを介して利用するAPNsでも、直接公式ドキュメントでの言及はありませんが制限が設けられていると思われます。
それぞれの詳細は以下のとおりです。

#### FCMが定める上限

FCMにおけるプッシュ通知の送信レート制限については、
[FCM メッセージについて](https://firebase.google.com/docs/cloud-messaging/concept-options?hl=ja#throttling-and-scaling)
のドキュメント内に記載されています。

主な制限は以下のとおりです。

- 1台のデバイスに送信できるメッセージ
  - 1分あたり最大240件
  - 1時間あたり最大5000件
- アップストリームメッセージの制限
  - プロジェクトあたり1500000件/分
  - デバイスあたり1000件/分
- トピック・デバイスグループを対象とした送信（ファンアウト）
  - プロジェクトあたりの同時ファンアウト数1000
  - プロジェクトあたりのファンアウト数10000 QPS
- トピック登録・解除の制限
  - トピック登録の追加・解除はプロジェクトごとに3000 QPS

これを超える送信レートで送信リクエストを送った場合は、FCMから429 QUOTA_EXCEEDEDのエラー応答が返されます。

サンプルアプリケーションにおける通知のユースケースでは、いずれも通知の送信頻度や送信対象台数は多くないため、
基本的にはこれらの送信レートに抵触することはないと考えられます。
FCMから429 QUOTA_EXCEEDEDが返ってきた場合には、後述するエラーハンドリングの再送制御の指針に従って、時間をおいてから再送信を試みます。

#### APNsが定める上限

通知に関する送信上限について明確に記載された最新のドキュメントは見つけられませんでした。

Appleのドキュメントアーカイブに残されている過去のドキュメントとしては、
[Troubleshooting Push Notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)がありました。
ここでは、"There are no caps or batch size limits for using APNs."と記載されています。

しかしAPNsが返しうるステータスコードの中には429が含まれています。
その理由としては、"The server received too many requests for the same device token."と記載されています。
そのため、同一のデバイスにあまりにも高頻度に送信すると制限されることが予想されます。

こちらも同様に、サンプルアプリケーションにおける通知のユースケースでは送信上限に抵触することはないと考えられます。
APNsから429 TooManyRequestsの応答が返ってきた場合には、後述するエラーハンドリングの再送制御の指針に従って、時間をおいてから再送信を試みます。

### エラーハンドリング

#### エラー応答の種類

FCMへの通知送信リクエストの詳細は、
[こちらの公式ドキュメント](https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages/send)に記載されています。

送信リクエストが成功した場合は、レスポンスボディとしてメッセージのインスタンスが返されます。
エラー応答については、ドキュメント内には記載されていませんでしたが、
例えば無効な登録トークンを指定した場合、以下のような形式で返ってきます。

<!--
TODO: 具体的なエラーレスポンスの形式を後で確認して記載。
過去に調べた人の結果によると、おそらく以下のような形式で返ってくるはず。
-->

```json
{
  "error": {
    "code": 404,
    "message": "Requested entity was not found.",
    "status": "NOT_FOUND",
    "details": [
      {
        "@type": "type.googleapis.com/google.firebase.fcm.v1.FcmError",
        "errorCode": "UNREGISTERED"
      }
    ]
  }
}
```

エラー原因によってレスポンスボディのerror.detailsに含まれる内容が異なります。
FCMが返したエラーの場合は、FcmError形式のデータが入っています。
APNsが返したエラーをFCMが仲介して返した場合は、ApnsError形式のデータが入っています。
それぞれの形式の詳細は以下のとおりです。

- [FcmError](https://firebase.google.com/docs/reference/fcm/rest/v1/FcmError)
- [ApnsError](https://firebase.google.com/docs/reference/fcm/rest/v1/ApnsError)

FcmErrorに含まれるエラーコードの詳細は、
[ErrorCode](https://firebase.google.com/docs/reference/fcm/rest/v1/ErrorCode)
のドキュメント内に記載されています。

ApnsErrorに含まれるステータスコードや理由の詳細は、
[Handling Notification Responses from APNs](https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/handling_notification_responses_from_apns)
のドキュメント内に記載されています。

#### 再送制御

FCMから以下のエラー応答が返ってきた場合には、通知送信の一時的な失敗とその理由をログに記録した上で、時間をおいた後にFCMへの通知送信をリトライします。

- FcmError
  - 429 QUOTA_EXCEEDED
  - 503 UNAVAILABLE
  - 500 INTERNAL
- ApnsError
  - 429 TooManyRequests
  - 500 InternalServerError
  - 503 ServiceUnavailable
  - 503 Shutdown

リトライするまでの待機時間は、以下のルールに従って決定します。

- レスポンスヘッダにRetry-Afterが含まれている場合は、そのヘッダで指定された秒数だけ待機
- レスポンスヘッダにRetry-Afterが含まれていない場合は指数バックオフに従い、1秒、2秒、4秒と指数関数的に時間を増やしながら待機

リトライ回数の上限は、サンプルアプリケーションでは3回とします。

リトライ回数の上限に達しても送信に成功しなかった場合には、通知送信の失敗とその理由をログに記録します。
その後の処理については、通知のユースケースごとにアプリケーションのエラーハンドリングとして別途検討します。

#### 無効な登録トークンの削除

FCMから以下のエラー応答が返ってきた場合には、通知送信の失敗とその理由をログに記録した上で、バックエンドサーバに保存されている当該登録トークンを削除します。
その後の処理については、通知のユースケースごとにアプリケーションのエラーハンドリングとして別途検討します。

- FcmError
  - 404 UNREGISTERED
- ApnsError
  - 410 Unregistered

#### その他のエラーへの対応

その他のエラー応答が返ってきた場合には、通知送信の失敗とその理由をログに記録します。
その後の処理については、通知のユースケースごとにアプリケーションのエラーハンドリングとして別途検討します。

### 運用上の注意点

#### APNs Auth Keyの管理

APNs Auth Keyを使った認証形式は、過去の証明書を用いた形式と異なり有効期限はなく、更新運用は不要です。
その代わり、APNs Auth KeyはApple Developer Programのアカウント全体で2つまでしか発行できず、
アプリ単位ではなくアカウント全体で共用されるものとなります。

2つまでしか発行できず、APNs Auth Keyの移行期間中に並行運用することなどを考えると
開発・本番環境で別の鍵を利用するのも難しいです。
鍵ファイルの管理には最新の注意を払いましょう。

## 決定

:::note
最終的な決定内容を記録してください
:::
