---
title: FCMを用いたプッシュ通知の管理方針
---

Status: Proposed

<!--
Proposed: 提案中
Accepted: 採用
Rejected: 却下
Superseded: 廃止
-->

## 要約

:::note
ADRの決定事項を要約して、3行程度で記載してください。
:::

<!--
決めるポイント

- ログアウト中のユーザに時間割開始通知は届けるべき？届けないべき？
  - 届けない方がよいのでは。
  - 登録トークンをバックエンドから削除することで届かないようにするのがシンプルになりそう。

- iOS端末での通知許可確認ダイアログの表示タイミング
  - 一旦、方式設計段階のデモとしては、サインアップ完了後に通知許可ダイアログを表示する。
  - 今回のサンプルアプリでは特に通知の目的を説明する画面までは用意せず、ADRでこういうことも検討した方が良いと記載するに留める。
    - 具体的にどうするかは個別のアプリ実装時に検討してもらうものとする。

- 登録トークンの登録・更新タイミング
  - サンプルアプリではログアウト中のユーザには通知せずトークンを保持しないので、少なくともログイン完了以降である必要がある。
  - ログイン完了時に登録するものとする。
  - ログイン完了時にクライアント側でトークンが無いか無効になっていたりバックエンド側でトークンを保持していなければ再登録する
    - => クライアント側に生成日時を持っておく
    - => アプリ起動時に毎回トークンと生成日時を送り付けて、バックエンド側になければ登録する
    - => バックエンド側への送信に失敗した場合もアプリの処理は継続し、次回（自動）ログイン時に再送信する
    - この時、アプリの通知設定がOffで、Offだとトークンを生成できなかったらどうする？
      - この時点では登録できなくてよいが、どこかで通知設定がONになったことを検出し、そのタイミングで生成・バックエンドへの登録を行わないといけない
  - 同じくログイン完了時に、トークンの生成日時を見て定期更新が必要か判断し、更新が必要なら再登録する
    - => クライアント側で持っている生成日時を見て更新するか判断する
    - 以前のトークン生成日時はバックエンド側から取得する
      - クライアント側からアカウント情報を取得するAPIで、現在そのアカウントに登録されているトークンと生成日時の一覧を一緒に返す
      - 端末の時刻と比較することになるが、端末時刻は信用してよいか？
        - 日付が未来日になっていて余計に再登録されることには害がない
        - 日付が過去日になっていて定期更新がされないと問題が生じる場面はあるかも

- 登録トークンの保存形式
  - 登録トークンとタイムスタンプとセットでデータベースに保存
  - 保存場所はH2のデータベース
    - アカウントとFCMトークンを紐づけるテーブルを用意する (1アカウントに対しnトークン（今回はnにできないけど）)
    - 属性は、アカウントID, FCMトークン, 生成日時

- 登録トークンの削除タイミング
  - トークンが無効になっていたら消す
  - ログアウト時にも通知が届かないようにするため削除する
  - 通知がOffに変更されている場合は消さない
    - => そもそもOffになっている場合、消すべき登録トークンをクライアント側で取得できるのか？これがわからないとそもそも消せない。
      - => 検証する。
    - => もし取得できたとして、消す？
      - => 消してしまうと、通知ONの場合に再登録する必要が出てくる
      - => しかし通知ONになったことを常時監視し続けたくはない
      - => 今回は通知Offになった場合に消さないでおいて、通知Offの相手にも通知を送信し続けるものとする。
        - => 通知Offの相手に通知を送信した場合のバックエンドへのレスポンスと端末側の挙動を確認しておく

- 登録トークンの定期更新をやるか
  - ベストプラクティスに沿ってやった方がよさそうなのでやる
  - クライアント側で、アカウント情報と一緒に受け取ったトークンの生成日時を見て更新の必要性を判断する

- 通知に含めるデータ形式
  - 通知のタイプとパラメータをデータに含められるようにする。クライアント側はそのタイプとパラメータを見て必要なアクションをとる
    - 画面遷移が必要なら画面遷移させる
    - 将来的には、何かダイアログを出すようなケースもあるかも？

```
{
  "type": "StartTimeTable",
  "params": {
    "teamId": 123,
    "timetableId": 456,
  }
}
```
-->

## コンテキスト

:::note
この決定や変更をしなくてはいけない状況や問題などを説明してください。
:::

次の観点でFCMを用いたプッシュ通知の管理方針について議論・調査を進めていきます。

- デバイス登録トークンの管理
- レート制限
- エラーハンドリング

## 議論

### 登録トークンの管理

[FCM登録トークン管理のベストプラクティス](https://firebase.google.com/docs/cloud-messaging/manage-tokens)が公式のドキュメントとして用意されています。
サンプルアプリケーションでも基本的にはこのベストプラクティスに従うものとします。

#### 登録トークンの登録（バックエンド側）

[プッシュ通知方式の方針](./adr-009-push-notification-fcm.mdx)に従い、サンプルアプリケーションでは、デバイスグループを用いてユーザの各デバイスの登録トークンを管理します。
バックエンドサーバはAPIを通じてクライアントアプリから登録トークンを受け取り、FCM Admin SDKを通じてその登録トークンをFCMのデバイスグループに登録します。

データベースには、アカウントID、デバイスグループ名、デバイスグループの通知キーの組を保存するテーブルを用意して保存します。

また、FCM登録トークン管理のベストプラクティスに従い、登録トークンとそれが登録されたタイムスタンプもあわせてデータベースに保存します。
これは、使われなくなった古い登録トークンがどれなのか判別できる情報をバックエンド側に保持しておくことが目的です。
定期的にクライアントアプリ側で登録トークンを再生成して登録なおし、タイムスタンプを更新することで、
アプリが利用されなくなった登録トークンのタイムスタンプだけ古い日時のままとなります。
これにより、アプリが起動されなくなったデバイスをプッシュ通知の送信対象から除外するような対応が可能になります。
これは、大量のデバイスへ通知を送信するユースケースでのレート制限の回避やパフォーマンス改善につながります。

それに加え、FCMにはデバイスグループの削除を明示的に行うAPIは提供されていません。
デバイスグループから全ての登録トークンが削除された場合に自動的にデバイスグループが削除されます。
デバイスグループに登録されている登録トークンの一覧を取得するAPIも提供されていません。
そのため、デバイスグループを削除するためにも、デバイスグループに登録されている全ての登録トークンをバックエンド側でも管理しておく必要があります。

データベースには、デバイスグループの通知キー、登録トークン、デバイスグループへの登録日時のタイムスタンプの組を保存するテーブルを用意して保存します。

具体的なバックエンドサーバ側の処理の流れは以下のとおりです。

1. クライアントアプリからAPIを通じて登録トークンを受け取る
2. 認証情報からアカウントを特定し、アカウントIDに対応するデバイスグループの通知キーがデータベースに保存されているか確認する
3. デバイスグループの通知キーの有無に応じて、デバイスグループの新規作成、もしくはデバイスグループへの追加登録を行う
  a. デバイスグループの通知キーがデータベースに保存されている場合は、そのデバイスグループへ登録トークンを追加し、データベースを更新する
  b. デバイスグループの通知キーがデータベースに保存されていない場合は、登録トークンが参加するデバイスグループを新規作成し、データベースを更新する
4. クライアント側への応答として、登録トークンの登録日時のタイムスタンプを返す

#### 登録トークンの登録（クライアント側）

デフォルトでは、FCM SDKはアプリの起動時にクライアントアプリのインスタンスの登録トークンを生成します。
またそのタイミングでライブラリによりそのIDと構成データがFirebaseにアップロードされます。
サンプルアプリケーションでも、登録トークンの生成とFirebaseへの登録はFCM SDKのデフォルトにあわせてアプリの起動時に行います。
この時点でFirebaseへのデバイス登録は行われますが、まだバックエンドサーバ側では登録トークンを保持していないため、通知の送信対象にはしません。

サンプルアプリケーションではログインしていないデバイスへは通知を送信しません。
そのため、FCMのデバイスグループへはログイン中のデバイスの登録トークンのみを登録します。
そのためアプリ起動時ではなく、デバイス側でログインが完了したタイミングで登録トークン登録用APIを通じてバックエンドサーバへ送信します。
デバイスグループへの登録が成功した場合はAPIから成功応答を返し、クライアント側では登録が成功した登録トークンと登録日時のタイムスタンプをデバイスのストレージ内に保存します。

iOS端末の場合、登録トークンを利用して通知を送信するためには、このアプリからの通知の送信を許可するか確認するダイアログを表示し、許可を取る必要があります。
このダイアログも同じくログインが完了したタイミングで表示します。
ここで通知の送信をユーザが拒否した場合は、登録トークンのバックエンドサーバへの送信は行わないものとします。

:::info
iOS端末の場合、通知機能を利用する前にアプリ内で通知送信の許可を求めるダイアログを表示し、ユーザの意思を確認する必要があります。
それをユーザが拒否した場合、以降アプリ内では許可を求めるダイアログを再表示できず、
ユーザがOSの設定からアプリの通知をオンに設定しない限り通知機能は利用できません。

しかし少なくないユーザは、通知が何の目的で用いられるのか説明される前に許可を求めるダイアログが表示されると、許可しないを選択します。
これはユーザの体験を向上させる目的で通知機能を提供しているアプリにとって不幸なすれ違いです。

サンプルアプリケーションではログイン直後に説明なく通知の許可を求めるダイアログを表示していますが、
実際のアプリケーションではよりユーザが納得しやすい形で許可を求めるべきです。
この問題を改善するために、例えば以下のような方法を採用できます。

#### プッシュ通知が本当に必要になるタイミングで通知許可を要求する

例えば、特定の条件を満たした場合に通知を受け取るという設定がアプリ内に存在するとします。
この設定をオンに設定したタイミングで通知許可ダイアログを表示した場合、ユーザはこの通知を受け取るために通知の許可を要求しているのだと明確に理解できます。

#### プッシュ通知の目的を説明する画面を用意し、その画面で通知の目的に同意したユーザにのみiOSの提供する通知許可ダイアログを表示する

iOSが用意している通知許可ダイアログは一度しか表示できません。
そのため何度でも表示できる別の画面で一度ユーザの意向を確認した上で、同意してくれたユーザにのみiOSの提供する通知許可ダイアログを表示します。
用意した画面で同意しなかったユーザに対しても、後からいつでもその画面に遷移して通知を許可できるようにします。

#### アプリからOSの通知設定画面へ誘導する

一度iOSの通知許可ダイアログで拒否された場合、OSのアプリ設定の画面からしか通知設定は変更できません。
通知を有効化する方法をアプリ内で説明し、アプリ設定画面を開くためのボタンなどを用意しておくことで、設定を変更してもらえる可能性が高まります。
ただし、ユーザの意思を尊重せずに通知の有効化を強要するようなデザインにしてしまうと、ストア公開審査時に規約違反と判断される可能性があります。
:::

#### 登録トークンの更新

デバイスの登録トークンは以下の場合などに変更される可能性があります。

- アプリが元のデバイスから新しいデバイスに復元される
- ユーザがアプリをアンインストールまたは再インストールする
- ユーザがアプリデータをクリアする

初回起動時と同様、この場合もFCM SDKはデフォルトでは次回のアプリ起動時に登録トークンを生成します。
またそのタイミングでライブラリによりそのIDと構成データがFirebaseにアップロードされます。

サンプルアプリケーションでは、ログイン（自動ログイン含む）完了時に毎回、
デバイスのストレージ内に保存されている登録トークンと、FCM SDKから取得した最新の登録トークンに違いが無いか確認します。
両者が異なっていたり、ストレージ内のデータが消去されていた場合は、バックエンドサーバに新しい登録トークンを送信します。
バックエンドサーバは、受け取った登録トークンをデバイスグループに登録します。

iOSの通知送信許可を求めるダイアログも、再インストールなどにより再表示が必要な状態になっていれば、このタイミングで表示します。

また登録トークンが無効化された場合だけでなく、登録トークン生成日時をもとに定期的に登録トークンを更新します。
FCMでは、月に1度程度登録トークンとタイムスタンプを更新することを推奨しています。
サンプルアプリケーションでもそれに倣い、月に1度登録トークンとタイムスタンプを更新します。
ベストプラクティスではこの情報をもとに、2か月以上更新されていない古い登録トークンをデバイスグループからの登録解除やトピック購読解除を行うことを推奨しています。
サンプルアプリケーションではこの棚卸しまでは実施しません。

登録トークンの更新が必要かどうかは、ログイン（自動ログイン含む）完了時にデバイスのストレージ内に保存されている生成日時を見て判断します。
もし1か月以上経過している場合は、新しい登録トークンを生成し、登録トークン更新APIを通じて新旧両方の登録トークンをバックエンドサーバに送信します。
バックエンドサーバは古い登録トークンをデバイスグループから削除し、新しい登録トークンをデバイスグループに追加します。

#### 登録トークンの削除

FCMは、登録トークンを対象とした通知送信リクエストを受け取った場合、それが無効な登録トークンであれば以下のエラー応答を返します。

- UNREGISTERD (HTTP 404)
  - 指定した登録トークンがそのアプリに対して登録されていない場合に返されます
- INVALID_ARGUMENT (HTTP 400)
  - リクエストパラメータに問題がある場合に返されます
  - 登録トークンが問題の原因である場合は、Invalid registrationという理由が返されます

バックエンドサーバ側で登録トークンを管理している場合は、無効なトークンをバックエンドサーバから削除する必要があります。
デバイスグループで登録トークンを管理している場合は、デバイスグループへの通知送信時に無効なトークンが含まれていた場合はFCMによって登録が自動的に解除されます。

<!-- TODO: 本当にそうなっているか動作を確認する。 -->

また、今回のサンプルアプリケーションではログインしている端末にのみ通知を送信したいため、ログアウト時にもデバイスグループから登録トークンを削除する必要があります。
ログアウト時の登録トークン削除は、ログアウトのAPIで登録トークンをあわせて送信する方法と、別途登録トークン削除用のAPIを用意する方法が考えられます。
サンプルアプリケーションでは、ログアウトのAPIで登録トークンをあわせて送信するものとします。

その他の削除タイミングとして、アプリの設定で通知設定がOffに変更されたタイミングも考えられます。
このタイミングで削除する場合、次に通知設定がOnに変更されたことを検出し、そのタイミングで登録トークンをバックエンドサーバに再保存する必要があります。
サンプルアプリケーションでは、処理が複雑になることを避けるため、通知設定がOffに変更されたタイミングでは登録トークンを削除しないものとします。

### レート制限

FCMでは、プッシュ通知の送信レートの制限が設けられています。
また、FCMを介して利用するAPNsでも、直接公式ドキュメントでの言及はありませんが制限が設けられていると思われます。
それぞれの詳細は以下のとおりです。

#### FCMが定める上限

FCMにおけるプッシュ通知の送信レート制限については、
[FCM メッセージについて](https://firebase.google.com/docs/cloud-messaging/concept-options?hl=ja#throttling-and-scaling)
のドキュメント内に記載されています。

主な制限は以下のとおりです。

- 1台のデバイスに送信できるメッセージ
  - 1分あたり最大240件
  - 1時間あたり最大5000件
- アップストリームメッセージの制限
  - プロジェクトあたり1500000件/分
  - デバイスあたり1000件/分
- トピック・デバイスグループを対象とした送信（ファンアウト）
  - プロジェクトあたりの同時ファンアウト数1000
- トピック登録・解除の制限
  - トピック登録の追加・解除はプロジェクトごとに3000 QPS

これを超える送信レートで送信リクエストを送った場合は、FCMから429 QUOTA_EXCEEDEDのエラー応答が返されます。

サンプルアプリケーションにおける通知のユースケースでは、いずれも通知の送信頻度や送信対象台数は多くないため、
基本的にはこれらの送信レートに抵触することはないと考えられます。
FCMから429 QUOTA_EXCEEDEDが返ってきた場合には、後述するエラーハンドリングの再送制御の指針に従って、時間をおいてから再送信を試みます。

#### APNsが定める上限

通知に関する送信上限について明確に記載された最新のドキュメントは見つけられませんでした。

Appleのドキュメントアーカイブに残されている過去のドキュメントとしては、
[Troubleshooting Push Notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)がありました。
ここでは、"There are no caps or batch size limits for using APNs."と記載されています。

しかしAPNsが返しうるステータスコードの中には429が含まれています。
その理由としては、"The server received too many requests for the same device token."と記載されています。
そのため、同一のデバイスにあまりにも高頻度に送信すると制限されることが予想されます。

こちらも同様に、サンプルアプリケーションにおける通知のユースケースでは送信上限に抵触することはないと考えられます。
APNsから429 TooManyRequestsの応答が返ってきた場合には、後述するエラーハンドリングの再送制御の指針に従って、時間をおいてから再送信を試みます。

### エラーハンドリング

#### エラー応答の種類

FCMへの通知送信リクエストの詳細は、
[こちらの公式ドキュメント](https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages/send)に記載されています。

FCM Admin SDKを用いている場合、レスポンスからエラーコードを取得できます。
FCMのエラーコードの詳細は、[ErrorCode](https://firebase.google.com/docs/reference/fcm/rest/v1/ErrorCode)
のドキュメント内に記載されています。

APNs起因のエラーの詳細については、
[Handling Notification Responses from APNs](https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/handling_notification_responses_from_apns)
のドキュメント内に記載されています。

#### 再送制御

FCMから以下のエラー応答が返ってきた場合には、通知送信の一時的な失敗とその理由をログに記録した上で、時間をおいた後にFCMへの通知送信をリトライします。

- 429 QUOTA_EXCEEDED
- 503 UNAVAILABLE
- 500 INTERNAL

リトライするまでの待機時間は、以下のルールに従って決定します。

- レスポンスヘッダにRetry-Afterが含まれている場合は、そのヘッダで指定された秒数だけ待機
- レスポンスヘッダにRetry-Afterが含まれていない場合は指数バックオフに従い、1秒、2秒、4秒と指数関数的に時間を増やしながら待機

リトライ回数の上限は、サンプルアプリケーションでは3回とします。

リトライ回数の上限に達しても送信に成功しなかった場合には、通知送信の失敗とその理由をログに記録します。
その後の処理については、通知のユースケースごとにアプリケーションのエラーハンドリングとして別途検討します。

#### 無効な登録トークンの削除

FCMから以下のエラー応答が返ってきた場合には、通知送信の失敗とその理由をログに記録した上で、バックエンドサーバに保存されている当該登録トークンを削除します。
その後の処理については、通知のユースケースごとにアプリケーションのエラーハンドリングとして別途検討します。

- 404 UNREGISTERED

<!-- TODO: デバイスグループ宛に送信した場合、どういうレスポンスが返ってくるか要確認 -->

#### その他のエラーへの対応

その他のエラー応答が返ってきた場合には、通知送信の失敗とその理由をログに記録します。
その後の処理については、通知のユースケースごとにアプリケーションのエラーハンドリングとして別途検討します。

### 運用上の注意点

#### APNs Auth Keyの管理

APNs Auth Keyを使った認証形式は、過去の証明書を用いた形式と異なり有効期限はなく、更新運用は不要です。
その代わり、APNs Auth KeyはApple Developer Programのアカウント全体で2つまでしか発行できず、
アプリ単位ではなくアカウント全体で共用されるものとなります。

2つまでしか発行できず、APNs Auth Keyの移行期間中に並行運用することなどを考えると
開発・本番環境で別の鍵を利用するのも難しいです。
鍵ファイルの管理には最新の注意を払いましょう。

## 決定

:::note
最終的な決定内容を記録してください
:::
