---
title: HTTP API通信に関する方針
---

Status: Proposed

<!--
Proposed: 提案中
Accepted: 採用
Rejected: 却下
Superseded: 廃止
-->

## 要約

## コンテキスト

多くのモバイルアプリはリモート上のサーバと連携することで各種機能を実現します。
このアプリにおいても、REST APIを用いてバックエンドサーバと連携します。

React Native公式ドキュメントの[Networking](https://reactnative.dev/docs/network)にあるとおり、React NativeではFetch APIやXMLHttpRequest APIが用意されております。これらを用いることでHTTP API通信を実現できます。
以下のコードは、Fetch APIの使用例です。レスポンスから取得した映画のタイトルを画面に一覧表示しています。

```typescript
const Screen = () => {
  const [data, setData] = useState<ResponseData>({movies: []});

  useEffect(() => {
    fetch('https://reactnative.dev/movies.json')
      .then((response) => response.json())
      .then((json: ResponseData) => setData(json))
      .catch(() => {});
  }, []);

  return (
    <View>
      {data.movies.map((item) => (
        <View key={item.id}>
          <Text>{item.title}</Text>
        </View>
      ))}
    </View>
  );
};
```

このコードは一見正しく（運が良ければ）正常に動作します。
しかしながら、プロダクトコードとしては多くの考慮が足りていません。

- 再フェッチの仕組みが用意されていない（コンポーネントマウント時のみフェッチされる）
- ローディング状態時は画面が真っ白となる
- エラーハンドリングが疎か
- 通信中にコンポーネントがアンマウントされた場合のキャンセル処理がない

:::note
上記を考慮したデータ取得の方法は、（React公式ドキュメント「[パフォーマンス最適化](https://ja.reactjs.org/docs/hooks-faq.html#performance-optimizations)」のヒント欄で紹介されている）[こちらの記事](https://www.robinwieruch.de/react-hooks-fetch-data/)をご覧ください。
:::

これらに対応したデータ取得処理を実装すると、多くのコード記述が必要となります。
これらは定型コード（ボイラープレートコード）となるため、適切な共通化が必要です。

また、バックエンドデータを適切に扱うには、上記に加え次の考慮が必要となります。

- バックエンドデータの特性に応じた管理
  - データは知らない誰かに変更される可能性がある
  - データは「古くなり」または「時代遅れ」となる可能性がある
- ページングや無限スクロールへの対応
  - 膨大なデータからアプリ内で必要なデータのみを取得し表示する
- キャッシング
  - パフォーマンスへの考慮
  - オフライン対応
- 再フェッチやポーリング
  - 「古い」データを「新しく」する

ここでは、上記課題解消を目的として、このアプリで利用するHTTP API通信方式について検討します。

## 議論

### HTTP API通信実装に向けた技術選定

このアプリでHTTP API通信を実装するにあたり、次の2つの案があります。

- HTTP API通信にはFetch APIなどを利用し、その非同期状態や取得したバックエンドデータはReduxにより管理
- データフェッチ用ライブラリの導入

Fetch APIとReduxを用いる案は、次の理由により採用しないこととします。

1. ReduxのStoreはクライアントの状態を管理するものであり、バックエンドデータのキャッシュ管理に用いるのは不適切。
2. Reduxで本格的に非同期処理を扱う場合、redux-thunkやredux-sagaの導入が必要となる。
3. キャッシュデータの有効期限管理や再フェッチ、ポーリングなど、必要な機能を自前で実装する必要がある。
4. このアプリではReduxを採用していない。

データフェッチ用ライブラリを導入するにあたり、いくつかの候補を挙げて比較検討します。
Reactの有名なデータフェッチ用ライブラリとしては次のものがあります。

- React Query
- SWR
- RTK Query
- Apollo Client
- URQL

React Query、SWRは、Reactフックを用いたデータフェッチ用ライブラリです。
いずれのライブラリもHTTP API通信をフックで宣言的に記述でき、通信状態に応じたレンダリング定義が可能となります。
RTK Queryは、Reduxアプリのデータフェッチを簡素化するのに役立ちます。
Apollo Client、URQLは、GraphQLを使用したデータフェッチ用ライブラリです。

このアプリはREST APIを用いるため、React Query、SWRは導入候補となります。
一方、ReduxやGraphQLを使用していないため、RTK Query、Apollo Client、URQLは導入候補から外します。

上記理由により、React Query、SWRに絞り比較しました。
比較結果は次のとおりです。

|                | React Query      | SWR                |
| :------------- | :--------------- | :----------------- |
| ライセンス     | MIT License      | MIT License        |
| 開発母体       | 個人             | Vercel Inc.        |
| 人気           | 25k star(GitHub) | 20.8k star(GitHub) |
| 機能数         | ◎                | △                  |
| コードの記述量 | 〇               | 〇                 |

#### ライセンス

ライセンスはいずれもMIT Licenseです。

#### 開発母体

開発母体はReact Queryが個人開発なのに対し、SWRはNext.jsの開発元として有名なVercelが開発しています。
SWRのほうが開発母体として安定性を感じます。

#### 人気

人気はGitHubのスターで確認する限りは同じくらいに見えます。

#### 機能数

機能数はReact Query公式ドキュメントが用意している[比較資料](https://react-query.tanstack.com/comparison)を参考にしました。
（React Query公式ドキュメントの為）React Query側に有利に書かれている懸念はありますが、内容を確認する限り公平性は保てているようです。
比較資料にあるとおり、SWRのほうが機能が少ないです。バンドルサイズや公式ドキュメントの量もそれを裏付けているように見えます。

React QueryにありSWRにない、いくつかの機能は次の通りです。

- `Devtools`
- ミューテーションフック（`Mutation Hooks`）
- 自動ガーベージコレクション（`Auto Garbage Collection`）と有効期間の設定（`Stale Time Configuration`）

React QueryのDevtoolsは魅力的な機能ですが、React Nativeではサポートされていません。
React Queryはミューテーションフックを用意しており、更新時の非同期状態も管理できます。
SWRは標準でその機能が用意されてません。
自動ガーベージコレクションと有効期間の設定は、クエリをキャッシュして管理する機能です。
これらは`staleTime`と`cacheTime`で設定できます。

- `staleTime`：クエリが「新しい」ものから「古くなる」までの期間。クエリが「新しい」限り、クエリは取得済みのデータを返すため、ネットワークリクエストは発生しません。クエリが「古い」場合（デフォルトはフェッチ後すぐ古くなる）、クエリは取得済みのデータを返し、特定の条件下でバックグラウンドで再フェッチします。
- `cacheTime`：未使用なクエリを削除するまでの期間（デフォルトで5分）。クエリを使用するすべてのコンポーネントがアンマウントされると、そのクエリは未使用となります。

詳細は[Caching Examples](https://react-query.tanstack.com/guides/caching)を参照してください。
SWRはこの機能を備えていないようです。

#### コードの記述量

コードの記述量は、SWRのほうがキャッシュキーを非同期関数の引数として用いているためシンプルに見えますが、大差はありません。
キャッシュキーと非同期関数が独立しているReact Queryのほうが、キャッシュキーの管理面で柔軟性を感じます。

```typescript
const {data, error} = useSWR('https://reactnative.dev/movies.json', fetcher);
```

```typescript
const {isLoading, error, data} = useQuery('movies', () =>
  fetch('https://reactnative.dev/movies.json').then((response) => response.json()),
);
```

#### 検討結果

検討の結果、機能の充実度を主な理由としてReact Queryを採用します。

### 開発方針

React Queryを用いる上で、このアプリの開発方針について検討します。

#### クエリのデフォルトオプションについて

React Queryには多数のオプションが用意されております。
これらのオプションは、全てのクエリで有効な値を設定することが出来、かつクエリ毎にその値を上書きできます。
ここでは、これらいくつかのオプションについて、このアプリの特性に応じた設定値を検討します。
特に、React Query公式ドキュメントの[Important Defaults](https://react-query.tanstack.com/guides/important-defaults)で示されるオプションについては、デフォルトのままで問題ないかを注意深く検討します。

##### queryFn

[Default Query Function](https://react-query.tanstack.com/guides/default-query-function)で紹介されているとおり、デフォルトのクエリ関数を定義出来ます。
これにより、SWRのようなシンプルな記述を実現することが出来ます。
しかしながら、このアプリではOpenAPI仕様からソースコードを自動生成することにより、REST APIとの整合性や開発効率性の向上を図ります。
その為、このオプションは利用しません。

##### retry

クエリ失敗時のリトライ回数です。[Important Defaults](https://react-query.tanstack.com/guides/important-defaults)で示されるとおり、デフォルト値は3です。
このアプリでは、[HTTP API 通信のリトライ](../application-architecture/http-api/http-api-error-handling.mdx#http-api通信のリトライ)に従いリトライはユーザ自身の判断とします。
`false`をデフォルト値として設定します（リトライしません）。

##### retryOnMount

マウント時にリトライするかどうかです。
デフォルト値は`true`です。デフォルト値のままとします。

##### retryDelay

リトライ時の遅延間隔を示します。
デフォルトでは、リトライの度に指数関数的に待ち時間が増えていきます（Exponential Backoff）。
デフォルト値のままとします。

##### staleTime

クエリが「新しい」ものから「古くなる」までの期間です。[Important Defaults](https://react-query.tanstack.com/guides/important-defaults)で示されるとおり、デフォルト値は0です。
デフォルト値のままとし、必要に応じて各クエリ毎に個別で設定することとします。

##### cacheTime

未使用なクエリを削除するまでの期間です。[Important Defaults](https://react-query.tanstack.com/guides/important-defaults)で示されるとおり、デフォルト値は5分です。
デフォルト値のままとし、必要に応じて各クエリ毎に個別で設定することとします。

##### refetchOnMount

マウント時に再フェッチするかどうかを示します。
デフォルト（`true`）では、データが古くなっている場合に再フェッチします。
デフォルト値のままとします。

##### refetchOnWindowFocus

ウィンドウフォーカス時に再フェッチするかどうかを示します。
デフォルト（`true`）では、データが古くなっている場合に再フェッチします。
デフォルト値のままとします。

##### refetchOnReconnect

再接続時に再フェッチするかどうかを示します。
デフォルト（`true`）では、データが古くなっている場合に再フェッチします。
デフォルト値のままとします。

##### structuralSharing

デフォルト（`true`）では、クエリ結果のデータの中身が変更されていない場合、データの参照が変更されません。
これによりアプリのパフォーマンス向上が望めます。
デフォルト値のままとしますが、クエリ結果の比較がパフォーマンス上の問題を引き起こす場合は、個別で`false`に設定こととします。

##### onError

エラーハンドリングの共通処理を設定します。

#### ミューテーションのデフォルトオプションについて

クエリ同様、ミューテーションにおいても全てのミューテーションで有効な値を設定することが出来ます。

##### onError

エラーハンドリングの共通処理を設定します。

#### ソースコードの自動生成について

:::note
OpenAPI仕様からソースコードを自動生成。

- OpenAPI Generator
- Orval

:::

:::note
下記項目は自動生成にやり方に応じて判断

- 共通処理のためのラッパーフックを作る？
- cache毎もしくはAPI毎にフックを作るのはよさげ

:::

#### データ更新時のキャッシュの扱いについて

React Queryでは、クエリは取得済みのデータを返し必要に応じてバックグラウンドで再フェッチします。
これは頻繁なローディングインジケーターの表示を抑えUX向上に役立ちます。
一方で、更新後も一時的に古いデータが見えるため注意が必要です。

React Queryの公式ドキュメントでは、データ更新時にデータを最新化する2つの方法が提示されています。

1. [Invalidation from Mutations](https://react-query.tanstack.com/guides/invalidations-from-mutations)
2. [Updates from Mutation Responses](https://react-query.tanstack.com/guides/updates-from-mutation-responses)

1つめは、ミューテーション成功時にキャッシュしたクエリを無効にする方法です。
これにより、対象となるクエリはバックグラウンドで再フェッチを試みます。
この方法は再フェッチが終了するまで一時的に古いデータが表示されるため、ユーザの混乱を引き起こす可能性があります。

2つめは、ミューテーション成功時にレスポンスの値でキャッシュデータを更新する方法です。
パフォーマンスに優れた方法ですが、レスポンスで更新後の値を取得できることが前提となります。
また、やや実装が複雑となります。

このアプリにおいては、更新後に古いデータが見えることなく、かつできるだけシンプルな方法でデータを最新化したいです。
そこで、ミューテーション成功時に再フェッチが必要なクエリのキャッシュデータを破棄することで、古いデータを表示させない方針とします。コード例は次の通りです。

```typescript jsx
const mutation = useMutation(addTodo, {
  onSuccess: () => {
    queryClient.resetQueries('todos');
  },
});
```

このコードでは、新しいタスクを追加した後にToDoリストのキャッシュデータを破棄します。
これにより再フェッチ中は画面にローディングインジケーターが表示されることとなりますが、古いデータが表示されることはありません。

#### 二重送信防止について

Webアプリケーション同様に、モバイルアプリにおいても二重送信を防ぐ仕組みが必要です。
しかし、商品購入のような重要操作の二重実行を完全に防ぐ為には、バックエンド側での対策（トークンを用いたチェックなど）が必要です。
バックエンド側の対策はここでの検討範囲外とし、更新ボタンの二重押下のような、ユーザの操作ミスによる二重送信を防ぐための対策を検討します。

対策として、次の案があります。

- 送信（ローディング）中も一切の操作を制限しない
- 送信（ローディング）中は対象ボタンのみを押下不可
- 送信（ローディング）中は対象画面全体を操作不可（画面遷移は可能）
- 送信（ローディング）中はアプリ全体を操作不可（画面遷移は不可能）

下の案にいくほどユーザ操作が制限されるため、ユーザビリティが落ちます。
一方で、下の案ほどユーザ操作を制限できるため、予期せぬ操作への考慮が不要となります。

一般的に参照操作に比べて更新操作はそれほど多くありません。
その為、更新中の操作を制限することはそれほどユーザビリティに影響を与えないと判断し、このアプリにおいては次の方針とします。

- 初期ロードなどの参照操作については、一切の操作を制限しない
- 検索ボタン押下などの参照操作については、対象ボタンのみを押下不可とする
- ユーザ設定更新のような再実行可能な更新操作については、対象ボタンのみを押下不可とする
- 商品購入のような重要操作については、アプリ全体を操作不可とする

#### エラーハンドリング

[HTTP API 通信で発生するエラーのハンドリング](../application-architecture/http-api/http-api-error-handling.mdx)に従います。
また、エラーハンドリングの共通処理は、デフォルトオプションの`onError`にハンドラ関数を設定することで実現します。

#### ページネーションや無限スクロールへの対応

リモートにある膨大なデータからアプリ内で必要なデータのみを取得し表示するには、ページネーションや無限スクロールへの対応が必要です。
React Queryにはページネーションや無限スクロールの仕組みが用意されているのでそれに従います。

- [Paginated / Lagged Queries](https://react-query.tanstack.com/guides/paginated-queries)
- [Infinite Queries](https://react-query.tanstack.com/guides/infinite-queries)

ここでは、ページネーションや無限スクロールを実現するために必要なバックエンドAPIの仕様について検討します。
バックエンドAPIの仕様はアプリ内で統一することとします。

##### ページネーション

ページネーションを実現する為には、バックエンドAPIのリクエスト項目にページ番号が必要です。
さらにはページサイズやソート順を指定できるのが望ましいです。
また、全ページ数を表示するにはレスポンスにその値が必要です。

ページネーションを実現するにあたり、標準的な仕様は特に見当たりませんでした。
そこで、[Spring Data REST Reference Guide の 5. Paging and Sorting](https://docs.spring.io/spring-data/rest/docs/current/reference/html/#paging-and-sorting)を参考に次の通りとします。

| URLクエリパラメータ  | 説明           | 必須 |
| :------------------- | :------------- | :--- |
| page                 | 開始ページ番号 | ○    |
| size                 | ページサイズ   |      |
| sort                 | ソート項目     |      |

トータル件数は、HTTPボディの`page`オブジェクトの項目として返却します。

| `page`オブジェクトの項目 | 説明             | 必須 |
| :----------------------- | :--------------- | :--- |
| totalElements            | トータル件数     | ○    |
| totalPages               | トータルページ数 | ○    |

##### 無限スクロール

無限スクロールを実現する為には、カーソル（ソート可能なID）が必要です。
さらには最大取得件数を指定できるのが望ましいです。
また、レスポンスには次のデータ位置を指し示すカーソルが必要です。

無限スクロールを実現するにあたり、標準的な仕様は特に見当たりませんでした。
そこで、[Infinite Queries](https://react-query.tanstack.com/guides/infinite-queries)のサンプルコードを参考に次の通りとします。

| URLクエリパラメータ  | 説明         | 必須 |
| :------------------- | :----------- | :--- |
| cursor               | カーソル     | ○    |
| limit                | 最大取得件数 |      |

次のデータ位置を指し示すカーソルは、HTTPボディの項目として返却します。
次のカーソルがない場合はnullを返却します（※1）

| HTTPボディの項目  | 説明         | 必須 |
| :---------------- | :----------- | :--- |
| nextCursor        | 次のカーソル | ※1   |

## 決定

HTTP API通信を実装するにあたり、いくつかのデータフェッチ用ライブラリを比較検討しました。
このアプリでは、機能の充実度を主な理由としてReact Queryを採用します。

また、React Queryを用いる上での開発方針について検討しました。
その結果は次の通りです。

- このアプリの特性に応じていくつかのデフォルトオプションを変更する
- ソースコードの自動生成（TODO）
- データ更新時は関係するクエリのキャッシュデータを破棄する
- 二重送信防止のため、ユーザ操作に応じた操作制限を実施する
- エラーハンドリングの共通処理は、デフォルトオプションの`onError`に設定したハンドラ関数内で実現する
- ページネーションや無限スクロールで用いるバックエンドAPIの仕様はアプリ内で統一する
