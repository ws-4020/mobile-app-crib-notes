---
title: HTTP API通信に関する方針
---

Status: Proposed

<!--
Proposed: 提案中
Accepted: 採用
Rejected: 却下
Superseded: 廃止
-->

## 要約

## コンテキスト

多くのモバイルアプリはリモート上のサーバと連携することで各種機能を実現します。
このアプリにおいても、REST API を用いてバックエンドサーバと連携します。

React Native 公式ドキュメントの[Networking](https://reactnative.dev/docs/network)にあるとおり、React Native では Fetch API や XMLHttpRequest API が用意されております。これらを用いることで HTTP API 通信を実現できます。
以下のコードは、Fetch API で取得した映画のタイトルを一覧表示します。

```typescript
const Screen = () => {
  const [data, setData] = useState<ResponseData>({movies: []});

  useEffect(() => {
    fetch('https://reactnative.dev/movies.json')
      .then((response) => response.json())
      .then((json: ResponseData) => setData(json))
      .catch(() => {});
  }, []);

  return (
    <View>
      {data.movies.map((item) => (
        <View key={item.id}>
          <Text>{item.title}</Text>
        </View>
      ))}
    </View>
  );
};
```

このコードは一見正しく（運が良ければ）正常に動作します。
しかしながら、プロダクトコードとしては多くの考慮が足りていません。

- コンポーネントマウント時以外の再読み込み
- ローディング状態
- エラーハンドリング
- コンポーネントがアンマウントされた場合のキャンセル処理

:::note
上記を考慮したデータ取得の方法は、（React 公式ドキュメント「[パフォーマンス最適化](https://ja.reactjs.org/docs/hooks-faq.html#performance-optimizations)」のヒント欄で紹介されている）[こちらの記事](https://www.robinwieruch.de/react-hooks-fetch-data/)をご覧ください。
:::

上記考慮に対応したデータ取得処理を実装すると、多くのコード記述が必要となります。
ボイラープレートコードを抑えるためには適切な共通化が必要です。

また、バックエンドデータを扱う場合は、上記に加え次の考慮が必要となります。

- バックエンドデータの特性に応じた管理
  - データは知らない誰かに変更されるかもしれない
  - データは「古くなり」または「時代遅れ」となるかもしれない
- ページングや無限スクロールへの対応
  - 膨大なデータをすべてアプリ内で管理できない
  - 必要なデータのみを取得し表示する
- キャッシング
  - パフォーマンスへの考慮
  - オフライン対応
- 再フェッチやポーリング
  - 「古い」データを新しくする

ここでは、上記課題解消を目的として、このアプリで利用する HTTP API 通信方式について検討します。

## 議論

### HTTP API 通信実装に向けた技術選定

React で HTTP API 通信を実装するにあたり、次の 2 つの案があります。

- HTTP API 通信には Fetch API などを利用し、その非同期状態や取得したバックエンドデータは Redux により管理
- データフェッチ用ライブラリの導入

Fetch API と Redux を用いる案は、次の理由により採用しないこととします。

1. Redux の Store はクライアントの状態を管理するものであり、バックエンドデータのキャッシュ目的に用いるのは不適切。
2. Redux で本格的に非同期処理を扱う場合、redux-thunk や redux-saga の導入が必要となる。
3. キャッシュデータの有効期限管理や再フェッチ、ポーリングなど、バックエンドデータ管理に必要な機能を自前で実装する必要がある。
4. このアプリでは Redux を採用していない。

React の有名なデータフェッチ用ライブラリとしては次のものがあります。

- React Query
- SWR
- RTK Query
- Apollo Client
- URQL

React Query、SWR は、React フックを用いたデータフェッチ用ライブラリです。
いずれのライブラリも HTTP API 通信をフックで宣言的に記述でき、通信状態に応じたレンダリング定義が可能となります。
RTK Query は、Redux アプリのデータフェッチを簡素化するのに役立ちます。
Apollo Client、URQL は、GraphQL を使用したデータフェッチ用ライブラリです。

このアプリは REST API を用いるため、React Query、SWR は導入候補となります。
このアプリでは Redux や GraphQL を使用していないため、RTK Query、Apollo Client、URQL は導入候補から外します。

上記理由により、React Query、SWR に絞り比較しました。
比較結果は次のとおりです。

|                | React Query      | SWR                |
| :------------- | :--------------- | :----------------- |
| ライセンス     | MIT License      | MIT License        |
| 開発母体       | 個人             | Vercel Inc.        |
| 人気           | 25k star(GitHub) | 20.8k star(GitHub) |
| 機能数         | ◎                | △                  |
| コードの記述量 | 〇               | 〇                 |

#### ライセンス

ライセンスはいずれも MIT License です。

#### 開発母体

開発母体は React Query が個人開発なのに対し、SWR は Next.js を開発している会社として有名な Vercel Inc.が開発しています。
SWR のほうが開発母体として安定性を感じます。

#### 人気

人気は GitHub のスターで確認する限りは同じくらいに見えます。

#### 機能数

機能数は React Query 公式ドキュメントが用意している[比較資料](https://react-query.tanstack.com/comparison)を参考にしました。
（React Query 公式ドキュメントの為）React Query 側に有利に書かれている懸念はありますが、内容を確認する限り公平性は保てているようです。
比較資料にあるとおり、SWR のほうが機能が少ないです。バンドルサイズや公式ドキュメントの量もそれを裏付けているように見えます。

React Query にあり SWR にない、いくつかの機能は次の通りです。

- `Devtools`
- ミューテーションフック（`Mutation Hooks`）
- 自動ガーベージコレクション（`Auto Garbage Collection`）と有効期間の設定（`Stale Time Configuration`）

React Query の Devtools は魅力的な機能ですが、React Native ではサポートされていません。

React Query はミューテーションフックを用意しており、更新時の非同期状態も管理できます。
SWR は標準でその機能が用意されてないみたいです。

自動ガーベージコレクションと有効期間の設定は、キャッシュデータを管理する機能です。
これらは`cacheTime`と`staleTime`で設定できます。

- `staleTime`：キャッシュデータが「新しい」ものから「古くなる」までの期間です。キャッシュデータが「新しい」限り、クエリはキャッシュデータを返すため、ネットワークリクエストは発生しません。キャッシュデータが「古い」場合（デフォルトはフェッチ後すぐ）、クエリはキャッシュデータを返し、特定の条件下でバックグラウンドで再フェッチします。
- `cacheTime`：未使用なクエリのキャッシュデータを削除するまでの期間（デフォルトで 5 分）です。クエリを使用するすべてのコンポーネントがアンマウントされると、そのクエリは未使用となります。

詳細は[Caching Examples](https://react-query.tanstack.com/guides/caching)を参照してください。
SWR はこの機能を備えていないようです。

#### コードの記述量

コードの記述量は、SWR のほうがキャッシュキーを非同期関数の引数として用いているためシンプルに見えますが、大差はありません。
キャッシュキーと非同期関数が独立している React Query のほうが、キャッシュキーの運用面で柔軟性があります。

```typescript
const {data, error} = useSWR('https://reactnative.dev/movies.json', fetcher);
```

```typescript
const {isLoading, error, data} = useQuery('movies', () =>
  fetch('https://reactnative.dev/movies.json').then((response) => response.json()),
);
```

#### 検討結果

上記比較検討の結果、機能の充実度を主な理由として React Query を採用します。

### React Query が提供する機能群

React Query が提供する代表的な機能を次に示します。

- クエリ
  - パラレルクエリ
  - 他のクエリに依存したクエリ
  - ページング
  - 無限スクロール
  - プリフェッチ
  - クエリのキャンセル
  - ポーリング・再フェッチ
- キャッシュ管理
  - キャッシュの有効期間設定
  - キャッシュの自動ガーベージコレクション
- ミューテーション
- 効率的な画面レンダリング
- 開発者ツール

:::

### React Query の設定項目とデフォルト値

クエリオプションの設定項目

|                               |     |
| :---------------------------- | :-- |
| queryKey                      |     |
| queryFn                       |     |
| enabled                       |     |
| retry                         |     |
| retryOnMount                  |     |
| retryDelay                    |     |
| staleTime                     |     |
| cacheTime                     |     |
| queryKeyHashFn                |     |
| refetchInterval               |     |
| refetchIntervalInBackground   |     |
| refetchOnMount                |     |
| refetchOnWindowFocus          |     |
| refetchOnReconnect            |     |
| notifyOnChangeProps           |     |
| notifyOnChangePropsExclusions |     |
| onSuccess                     |     |
| onError                       |     |
| onSettled                     |     |
| select                        |     |
| suspense                      |     |
| initialData                   |     |
| initialDataUpdatedAt          |     |
| placeholderData               |     |
| keepPreviousData              |     |
| structuralSharing             |     |
| useErrorBoundary              |     |
| meta                          |     |

|isDataEqual||
|queryHash||
|behavior||
|getPreviousPageParam||
|getNextPageParam||
|optimisticResults||

ミューテーションオプション

|                  |     |
| :--------------- | :-- |
| mutationFn       |     |
| mutationKey      |     |
| variables        |     |
| onMutate         |     |
| onSuccess        |     |
| onError          |     |
| onSettled        |     |
| retry            |     |
| retryDelay       |     |
| meta             |     |
| useErrorBoundary |     |

:::note

- React Query の設定項目の簡単な説明とデフォルト値について
- アプリで変更するデフォルト設定
  :::

### 開発方針

#### Reqct Query を用いた開発方針

:::note

- 共通処理のためのラッパーフックを作る？
- cache 毎 or API 毎にフックを作るのはよさげ
- データ更新時のキャッシュの扱いを調査
  :::

#### バックエンド API の定義について

:::note

- ページネーションの方法
  - リクエスト
    - Spring Boot の方法にあわせておけばいいかな？
  - レスポンス
    - RFC-5988 か RFC-8288 あたりを参考に
  - 参考 URl - https://docs.spring.io/spring-data/rest/docs/3.7.x/reference/html/#paging-and-sorting - https://gist.github.com/bernardolopes8/cf04f49e1b64bd47576e7204601ef126
    :::

#### エラーハンドリング

:::note
エラーハンドリング方針など
:::

## 決定
