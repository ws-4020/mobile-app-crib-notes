---
title: HTTP API通信に関する方針
---

Status: Proposed

<!--
Proposed: 提案中
Accepted: 採用
Rejected: 却下
Superseded: 廃止
-->

## 要約

## コンテキスト

多くのモバイルアプリはリモート上のサーバと連携することで各種機能を実現します。
このアプリにおいても、REST APIを用いてバックエンドサーバと連携します。

React Native公式ドキュメントの[Networking](https://reactnative.dev/docs/network)にあるとおり、React Nativeでは`Fetch API`や`XMLHttpRequest API`が用意されております。これらを用いることでHTTP API通信を実現できます。
以下のコードは`Fetch API`で取得した映画のタイトルを一覧表示します。

```typescript
const Screen = () => {
  const [data, setData] = useState<ResponseData>({movies: []});

  useEffect(() => {
    fetch('https://reactnative.dev/movies.json')
      .then(response => response.json())
      .then((json: ResponseData) => setData(json))
      .catch(() => {});
  }, []);

  return (
    <View>
      {data.movies.map(item => (
        <View key={item.id}>
          <Text>{item.title}</Text>
        </View>
      ))}
    </View>
  );
};
```
このコードは一見正しく（運が良ければ）正常に動作します。
しかしながら、プロダクトコードとしては多くの考慮が足りてません。

- コンポーネントマウント時以外の再読み込み
- ローディング状態
- エラーハンドリング
- コンポーネントがアンマウントされた場合のキャンセル処理

:::note
上記を考慮したデータ取得の方法は、（React公式ドキュメント「[パフォーマンス最適化](https://ja.reactjs.org/docs/hooks-faq.html#performance-optimizations)」のヒント欄で紹介されている）[こちらの記事](https://www.robinwieruch.de/react-hooks-fetch-data/)をご覧ください。
:::

上記考慮に対応したデータ取得処理を実装すると、多くのコード記述が必要となります。
ボイラープレートコードを抑えるためには適切な共通化が必要です。

また、バックエンドデータを扱う場合は、上記に加え次の考慮が必要となります。

- バックエンドデータの特性に応じた管理
  - データは知らない誰かに変更されるかもしれない
  - データは「古くなり」または「時代遅れ」となるかもしれない
- ページングや無限スクロールへの対応
  - 膨大なデータをすべてアプリ内で管理できない
  - 必要なデータのみを取得し表示する
- キャッシング
  - パフォーマンスへの考慮
  - オフライン対応
- リフェッチやポーリング
  - 「古い」データを新しくする

ここでは、上記課題解消を目的として、このアプリで利用するHTTP API通信方式について検討します。

## 議論

### HTTP API通信実装に向けた技術選定

ReactでHTTP API通信を実装するにあたり、次の2つの案があります。

- Reduxによる非同期状態やバックエンドデータの管理
- データフェッチ用ライブラリの導入

ReduxのStoreで非同期状態やバックエンドデータを管理する方法は、次の理由により採用しないこととします。

1. ReduxのStoreはクライアントの状態を管理するものであり、バックエンドデータのキャッシュ目的に用いるのは不適切。
2. Reduxで本格的に非同期処理を扱う場合、`redux-thunk`や`redux-saga`の導入が必要となる。
3. キャッシュデータの有効期限管理やリフェッチ、ポーリングなど、バックエンドデータ管理に必要な機能を自前で実装する必要がある。
4. このアプリではReduxを採用していない。

Reactの有名なデータフェッチ用ライブラリとしては次のものがあります。

- React Query
- SWR
- RTK Query
- Apollo Client
- URQL

React Query、SWRは、Reactフックを用いたデータフェッチ用ライブラリです。
いずれのライブラリもHTTP API通信をフックで宣言的に記述でき、通信状態に応じたレンダリング定義が可能となります。
RTK Queryは、Reduxアプリのデータフェッチを簡素化するのに役立ちます。
Apollo Client、URQLは、GraphQL使用したデータフェッチ用ライブラリです。

このアプリにおいても、REST APIを用いてバックエンドサーバと通信するため、React Query、SWRに絞り比較しました。
比較結果は次のとおりです。

||React Query|SWR|
|:--|:--|:--|
|ライセンス|MIT License|MIT License|
|開発母体|個人|Vercel Inc.|
|人気|25k star(GitHub)|20.8k star(GitHub)|
|機能数|◎|△|
|コードの記述量|〇|〇|

ライセンスはいずれもMIT Licenseです。
開発母体はReact Queryが個人開発なのに対し、SWRはNext.jsを開発している会社として有名なVercel Inc.が開発しています。
人気はGitHubのスターで確認する限りは同じくらいに見えます。
機能数はReact Query公式ドキュメントが用意している[比較資料](https://react-query.tanstack.com/comparison)を参考にしました。
やや公平性に欠けるかもしれませんが、内容を見る限り公平性は保てているようです。
バンドルサイズや公式ドキュメントの量で比較しても、SWRのほうが機能が少ないです。
コードの記述量は、SWRのほうがキャッシュキーを非同期関数の引数として用いているためシンプルに見えますが、大差はありません。

上記比較検討の結果、機能数を理由としてReact Queryを採用します。

### React Queryが提供する機能群

:::note
React Queryが提供する代表的な機能の紹介する？
全部は紹介せず代表的な次くらい。

- キャッシュ
	- 古いデータの管理
	- キャッシュ期間の管理
- 依存性管理
- ページング
- 無限スクロール
- 更新系

:::

### React Queryの設定項目とデフォルト値

:::note
- React Queryの設定項目の簡単な説明とデフォルト値について
- アプリで変更するデフォルト設定
- cacheTimeとstaleTimeの説明はあったほうがいい？
:::

### 開発方針

#### Reqct Queryを用いた開発方針

:::note
- 共通処理のためのラッパーフックを作る？
- cache毎 or API毎にフックを作るのはよさげ
- データ更新時のキャッシュの扱いを調査
:::

#### バックエンドAPIの定義について

:::note
- ページネーションの方法
  - リクエスト
    - Spring Bootの方法にあわせておけばいいかな？
  - レスポンス
    - RFC-5988かRFC-8288あたりを参考に
  - 参考URl
    - https://docs.spring.io/spring-data/rest/docs/3.7.x/reference/html/#paging-and-sorting
    - https://gist.github.com/bernardolopes8/cf04f49e1b64bd47576e7204601ef126
:::

#### エラーハンドリング

:::note
エラーハンドリング方針など
:::

## 決定
